% !TEX root = ./dissertation.tex
\section{Agda-fying Categories}

\subsection{Categories}

Categories can be constructed in Agda with relative simplicity. The initial
concepts introduced here are taken from \verb|cats|, a Category Theory library
in Agda by Jannis Limpberg. \AgdaBound{lo}, \AgdaBound{la} and \AgdaBound{l≈}
are used in the following section as variables of type \AgdaDatatype{Level}.

Categories can be introduced as a record parameterised by the level of their
objects, arrows and type of morphism equality respectively
\ExecuteMetaData[../agda/latex/ThesisCategory.tex]{cat-def}

Categories are typed at a level above the largest of objects, arrows and
equalities in order to present equality on morphisms as relations on types as
per the Agda standard library. The axioms of a category are presented as fields
of the record. Objects are permitted to be any type of any level and morphisms
typed as any function that takes two objects and returns a type.

Identity arrows and composition take their obvious definitions. The identity
arrow provides a distinguished morphism for each object implicitly and
composition is a function that takes two morphisms of the correct shape and
returns the appropriate morphism
\ExecuteMetaData[../agda/latex/ThesisCategory.tex]{cat-field-comp-id}

To codify the associativity of composition and the neutrality of identity it is
not practical to use propositional equality. Proving these as propositional
equalities of the structures that are often categorified is often a difficult
task. Propositional equality for a structure amounts to showing propositional
equality on its constituent components. That two terms are propositionally equal
implies the terms have the same normal form. There are often situations where it
is desirable to equate two different terms that do not have the same normal
forms. As an example, consider equating propositionally two monoid
homomorphisms. In a dependently typed setting this requires that the proofs of
preservation for the two morphisms are also equal in addition to the functions
between the underlying monoids. This is a tedious requirement that is often
undesired. \todo{Axiom K?}To remedy this, the earlier mentioned setoid model is
used whereby structures are equated by an equivalence relation.\todo{hott} For
categories an equivalence relation for morphism must be provided
\ExecuteMetaData[../agda/latex/ThesisCategory.tex]{cat-field-rel}

The \AgdaFunction{IsEquivalence} function establishes the appropriate proofs of
reflexivity, transitivity and symmetry.

With the notion of equality of morphisms in place it is possible to state the
properties of composition and identity

\ExecuteMetaData[../agda/latex/ThesisCategory.tex]{cat-field-comp}

The field \AgdaField{∘{-}resp} is a necessary and inconvenient aspect of
utilising equivalence relations over propositional equality. Preserves2
indicates that composition is congruent in both of its arguments. This allows us
to target individual compositions in a large categorical term to apply an
equality. This is given for free when using propositional equality as functions
are unable to distinguish terms with the same normal form. This can be seen as
one of the downsides to using equivalence relations as congruence must be proven
for every each individual equivalence relation.\todo{congruence}


\subsection{Uniqueness}

The next step in the categorical journey is a critical component of many of the
more complex abstractions, the notion of unique arrow

\ExecuteMetaData[../agda/latex/ThesisUnique.tex]{unique-def-unique}

Uniqueness is often given with respect to a property (hence universal
properties). In Agda this amounts to formulating the property as type
parameterised by the property and an arrow satisfying the property. The type
encodes a function which, given any other arrow satisfying the property
expresses equality to the parameterised arrow. Using this a general unique arrow
can be encoded using a trivial function that always returns the unit.

Universal properties can now be given as an object, a proposition and a proof of
uniqueness

\ExecuteMetaData[../agda/latex/ThesisUnique.tex]{unique-def-exun}

Agda's syntax directive can be used to create a universal property like type
\todo{syntax}, as in the characterisation of an object as terminal whereby an
object is terminal if, for any other object in the category, there is an arrow
from the object to the terminal alongside a proof of uniqueness.

\ExecuteMetaData[../agda/latex/ThesisUnique.tex]{unique-def-terminal}

A category having a terminal object can now be encoded as a proposition which
takes a category and provides an object alongside a proof that it is terminal

\ExecuteMetaData[../agda/latex/ThesisTerminal.tex]{terminal-def-has}

To prove Lawvere's Fixed Point Theorem within Agda and the various surrounding
proofs in logic, Cartesian Closed Categories must be formalised. For this, in
addition to terminal objects, binary products and exponentials will be needed

\ExecuteMetaData[../agda/latex/ThesisCCC.tex]{ccc-def-is-ccc}

Products and exponentials have slightly more involved definitions. Beginning
with the uniqueness principle for products

\ExecuteMetaData[../agda/latex/ThesisProduct.tex]{product-def-product}

\AgdaFunction{IsProduct} takes an indexing function, a product object, and some
projections out of the product into the components of the indexing
category. \AgdaFunction{IsProduct} returns a function type which, upon being
supplied a set of projections from an object to the indexing set, returns a
unique arrow from the the object to the previously supplied product object
satisfying the commuting diagrams for the product.


\subsection{Points}
All that follows is work done during this thesis. The theorem makes use of the
notion of points and some surrounding definitions

Points are a categorical abstraction that generalise the notion of elements of
a set. A point is an arrow from the terminal object to any other object

\ExecuteMetaData[../agda/latex/ThesisPoints.tex]{point-def-point}

Given the name of Lawvere's theorem it makes sense to formalise the notion of a
fixed point categorically

\ExecuteMetaData[../agda/latex/ThesisPoints.tex]{point-def-fixed-point}

A fixed point of a morphism is a point that is idempotent under composition to
the right with the morphism. As is common within the \verb|cats| library this is
then wrapped up in a record as a sigma type to express that a given function has
a fixed point

\ExecuteMetaData[../agda/latex/ThesisPoints.tex]{point-def-has-fixed-point}

Now the fixed point property which features in Lawvere's theorem can be
formalised which is a predicate on a object in a category expressing that all
endomorphisms on the object have a fixed point.

\ExecuteMetaData[../agda/latex/ThesisPoints.tex]{point-def-fixed-point-property}
 on the object have a fixed point.

Another useful feature in lawvere's theorem is the notion of point surjectivity
which itself requires some machinery. First the notion of a solved equation with
points

\ExecuteMetaData[../agda/latex/ThesisPoints.tex]{point-def-solution}

Point surjectivity expresses the notion that given a point to $B$, $b : 1
\rightarrow B$, and a morphism $f : A \rightarrow B$, we can produce a point to
$A$, $a : 1 \rightarrow A$, that satisfies the equation $f \circ a = b$.

Packaging this up into a sigma type which, given a morphism from an object A to
an object B and a point to B contains a point to A and a proof that is
constitutes a solution to the triple.

\ExecuteMetaData[../agda/latex/ThesisPoints.tex]{point-def-has-solution}

A point surjective morphism is a function for which every point to B there
exists a solution

\ExecuteMetaData[../agda/latex/ThesisPoints.tex]{point-def-is-point-surjective}

The formulation of the point surjectivity used in the theorem as a record
confirming the existence of a point surjective function between two objects

\ExecuteMetaData[../agda/latex/ThesisPoints.tex]{point-def-point-surjective}

\subsection{Lawvere's Fixed Point Theorem}

It is now possible to state Lawvere's theorem precisely, working within a
Cartesian Closed Category.

\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-type-diagonal}

Or mathematically that in a Cartesian Closed Category, given a point-surjective
function from some object $A$ to the exponential object, $B^A$, from $A$ to some object
$B$, every endomorphism on $B$ has a fixed point.

The proof of the theorem will be developed line by line. The first step is to
pattern match on the arguments to the proof and bring in the constructors for
the output type.

\begin{AgdaMultiCode}
\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-pattern}
\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-pattern-end}
\end{AgdaMultiCode}

The first argument to the proof is the point-surjective morphism constituting
the morphism and the proof of point-surjectivity, and the second argument is the
endomorphism on \verb|B|. The output, a record with holes, requires a point to
\verb|B| alongside a proof that it is a fixed point of \verb|f|.

To produce a fixed-point the goal is to create a morphism, \verb|g|,  from \verb|A| to
\verb|B| and then exploit the point-surjective morphism to find a point to
\verb|A|. With the correctly chosen \verb|g| the composition of this point to A
with \verb|g| will be a fixed-point. \verb|g| will be constructed such that is
in some way "self-replicating".

\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-h-def}

Categorically, \verb|g| represents the following diagram

\[\begin{tikzcd}[sep=huge]
    B & B \arrow[l, "f"] & B^A \times A \arrow[l, "eval"] & A \times A \arrow[l,
    "{\langle \phi \, , id\rangle}"] & A \arrow[l, "\delta"]
\end{tikzcd}\]

In order to push \verb|g| morphism back through the point-surjective morphism
it needs to be turned into a point to the exponential object. This can be
achieved via two isomorphisms, $1 \times A \cong A$ and $hom(A \times B \: , \, C)
\cong hom(A \: , \, C^B)$, the types and directions that are used proof as
follows

\begin{AgdaMultiCode}
\ExecuteMetaData[../agda/latex/ThesisExtension.tex]{extension-types-collapseToOne}
\ExecuteMetaData[../agda/latex/ThesisTypes.tex]{types-type-curry}
\end{AgdaMultiCode}

By applying the first isomorphism followed by the second, a point to $B^A$ can
be acquired
\begin{AgdaAlign}
\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-g'-def}

The point-surjectivity of $\phi$ can now be used to acquire the associated point
to \verb|A| with \verb|g'|

\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-ps-def}
\end{AgdaAlign}

The fixed point construction can now be achieved by composing $\phi$ with
\verb|u| twice to obtain a point to \verb|B|. After composing once with \verb|u|
a point to $B^A$ is obtained. This must be pushed through the aformentioned
isomorphisms to get a morphism, $A \rightarrow B$, to compose with \verb|u|
again.

\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-isos-proof}

Now it must be shown that \verb|f| $\circ$ \verb|fixedPoint| $\approx$
\verb|fixedPoint|. This proof will be developed using equational reasoning. The
proof starts with the word \AgdaFunction{begin} and the left-hand side of the
equality, with expressions separated by
equalities on morphisms, put inside
\AgdaOperator{\AgdaFunction{≈⟨}}\AgdaSpace{}\AgdaOperator{\AgdaFunction{⟩}}, and
ends with the right-hand side of the equality followed by
\AgdaOperator{\AgdaFunction{∎}}. In the case of the required proof

\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-fix-proof}

The first transformation in the proof is to use the point-surjectivity of
$\phi$ to expand the the $\phi$ $\circ$ \verb|u| within the definition of
\verb|fixedPoint| to \verb|g'|.

The proof of point-surjectivity is extracted as follows

\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-ps-proof}

This cannot be used directly due to the application of \AgdaFunction{curry} and
\AgdaFunction{extendToOne} to the expression. The usage of equivlance relations
means that congruence must be proved separately for every function on
morphisms. These two proofs have the following types but the proofs are elided
due to unecessary complexity.

\begin{AgdaSuppressSpace}
\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-uncurry-resp-prf}
\ExecuteMetaData[../agda/latex/ThesisExtension.tex]{extension-coll21-r-type}
\end{AgdaSuppressSpace}

To make \verb|ps-proof| work within the nested function applications they are
wrapped in the two proofs of congruence necessary

\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-col-unc-ps}

This can then be used by targeting the lefthand morphism of the outermost
composition and change this to \verb|g'|

\begin{AgdaMultiCode}
\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-col-unc-ps-trans}
\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-col-unc-ps-trans2}
\\
The next transformation is accomplished by utilising that \AgdaFunction{curry}
is an isomorphism with respect to \AgdaFunction{uncurry}, and that
\AgdaFunction{collapseToOne} is an isomorphism with respect to
\AgdaFunction{extendToOne}. With this \verb|g'| $\circ$ \verb|u| is obtained,
expanding \verb|g'|, \\
\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-col-unc-ps-trans2}
\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-g'-reduc}
\\
Before begin able to manipulate this expression the expression must be
reassociated. This is particularly tedious.

\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-reassoc}
\\
Once this has been achieved, definitions can be expanded and applied.
\AgdaFunction{$\delta$} is the unit of the diagonal-product adjunction and can
defined simply as \\

\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-delta}
\\
Intuitively, it can be seen that the precomposition of a morphism by an arrow to
a product object can fused to push the precomposed morphism into each branch of
the product object.


\end{AgdaMultiCode}
