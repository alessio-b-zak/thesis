% !TEX root = ./dissertation.tex
\section{Agda-fying Categories}

\subsection{Points} \todo{expand proofs further}
All that follows is work done during this thesis. The theorem makes use of the
notion of points and some surrounding definitions

Points are a categorical abstraction that generalise the notion of elements of
a set. A point is an arrow from the terminal object to any other object

\ExecuteMetaData[../agda/latex/ThesisPoints.tex]{point-def-point}

Given the name of Lawvere's theorem it makes sense to formalise the notion of a
fixed point categorically

\ExecuteMetaData[../agda/latex/ThesisPoints.tex]{point-def-fixed-point}

A fixed point of a morphism is a point that is idempotent under composition to
the right with the morphism. As is common within the \verb|cats| library this is
then wrapped up in a record as a sigma type to express that a given function has
a fixed point

\ExecuteMetaData[../agda/latex/ThesisPoints.tex]{point-def-has-fixed-point}

Now the fixed point property which features in Lawvere's theorem can be
formalised which is a predicate on a object in a category expressing that all
endomorphisms on the object have a fixed point.

\ExecuteMetaData[../agda/latex/ThesisPoints.tex]{point-def-fixed-point-property}
 on the object have a fixed point.

Another useful feature in lawvere's theorem is the notion of point surjectivity
which itself requires some machinery. First the notion of a solved equation with
points

\ExecuteMetaData[../agda/latex/ThesisPoints.tex]{point-def-solution}

Point surjectivity expresses the notion that given a point to $B$, $b : 1
\rightarrow B$, and a morphism $f : A \rightarrow B$, we can produce a point to
$A$, $a : 1 \rightarrow A$, that satisfies the equation $f \circ a = b$.

Packaging this up into a sigma type which, given a morphism from an object A to
an object B and a point to B contains a point to A and a proof that is
constitutes a solution to the triple.

\ExecuteMetaData[../agda/latex/ThesisPoints.tex]{point-def-has-solution}

A point surjective morphism is a function for which every point to B there
exists a solution

\ExecuteMetaData[../agda/latex/ThesisPoints.tex]{point-def-is-point-surjective}

The formulation of the point surjectivity used in the theorem as a record
confirming the existence of a point surjective function between two objects

\ExecuteMetaData[../agda/latex/ThesisPoints.tex]{point-def-point-surjective}

\section{Lawvere's Fixed Point Theorem}

It is now possible to state Lawvere's theorem precisely, working within a
Cartesian Closed Category.

\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-type-diagonal}

Or mathematically that in a Cartesian Closed Category, given a point-surjective
function from some object $A$ to the exponential object, $B^A$, from $A$ to some object
$B$, every endomorphism on $B$ has a fixed point.

The proof of the theorem will be developed line by line. The first step is to
pattern match on the arguments to the proof and bring in the constructors for
the output type.

\begin{AgdaMultiCode}
\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-pattern}
\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-pattern-end}
\end{AgdaMultiCode}

The first argument to the proof is the point-surjective morphism constituting
the morphism and the proof of point-surjectivity, and the second argument is the
endomorphism on \verb|B|. The output, a record with holes, requires a point to
\verb|B| alongside a proof that it is a fixed point of \verb|f|.

To produce a fixed-point the goal is to create a morphism, \verb|g|,  from \verb|A| to
\verb|B| and then exploit the point-surjective morphism to find a point to
\verb|A|. With the correctly chosen \verb|g| the composition of this point to A
with \verb|g| will be a fixed-point. \verb|g| will be constructed such that is
in some way "self-replicating".

\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-h-def}

Categorically, \verb|g| represents the following diagram

\[\begin{tikzcd}[sep=huge]
    B & B \arrow[l, "f"] & B^A \times A \arrow[l, "eval"] & A \times A \arrow[l,
    "{\langle \phi \, , id\rangle}"] & A \arrow[l, "\delta"]
\end{tikzcd}\]

In order to push \verb|g| morphism back through the point-surjective morphism
it needs to be turned into a point to the exponential object. This can be
achieved via two isomorphisms, $1 \times A \cong A$ and $\textnormal{hom}(A \times B \: , \, C)
\cong \textnormal{hom}(A \: , \, C^B)$, the types and directions that are used proof as
follows

\begin{AgdaMultiCode}
\ExecuteMetaData[../agda/latex/ThesisExtension.tex]{extension-types-collapseToOne}
\ExecuteMetaData[../agda/latex/ThesisTypes.tex]{types-type-curry}
\end{AgdaMultiCode}

By applying the first isomorphism followed by the second, a point to $B^A$ can
be acquired
\begin{AgdaAlign}
\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-g'-def}

The point-surjectivity of $\phi$ can now be used to acquire the associated point
to \verb|A| with \verb|g'|

\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-ps-def}
\end{AgdaAlign}

The fixed point construction can now be achieved by composing $\phi$ with
\verb|u| twice to obtain a point to \verb|B|. After composing once with \verb|u|
a point to $B^A$ is obtained. This must be pushed through the aformentioned
isomorphisms to get a morphism, $A \rightarrow B$, to compose with \verb|u|
again.

\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-isos-proof}

Now it must be shown that \verb|f| $\circ$ \verb|fixedPoint| $\approx$
\verb|fixedPoint|. This proof will be developed using equational reasoning. The
proof starts with the word \AgdaFunction{begin} and the left-hand side of the
equality, with expressions separated by
equalities on morphisms, put inside
\AgdaOperator{\AgdaFunction{≈⟨}}\AgdaSpace{}\AgdaOperator{\AgdaFunction{⟩}}, and
ends with the right-hand side of the equality followed by
\AgdaOperator{\AgdaFunction{∎}}. In the case of the required proof

\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-fix-proof}

The first transformation in the proof is to use the point-surjectivity of
$\phi$ to expand the the $\phi$ $\circ$ \verb|u| within the definition of
\verb|fixedPoint| to \verb|g'|.

The proof of point-surjectivity is extracted as follows

\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-ps-proof}

This cannot be used directly due to the application of \AgdaFunction{curry} and
\AgdaFunction{extendToOne} to the expression. The usage of equivlance relations
means that congruence must be proved separately for every function on
morphisms. These two proofs have the following types but the proofs are elided
due to unecessary complexity.

\begin{AgdaSuppressSpace}
\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-uncurry-resp-prf}
\ExecuteMetaData[../agda/latex/ThesisExtension.tex]{extension-coll21-r-type}
\end{AgdaSuppressSpace}

To make \verb|ps-proof| work within the nested function applications they are
wrapped in the two proofs of congruence necessary

\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-col-unc-ps}

This can then be used by targeting the lefthand morphism of the outermost
composition and change this to \verb|g'|. This is done using
\AgdaFunction{∘-resp-l} which allows a proof to be applied to chang the lefthand
side of a morphism composition.

\begin{AgdaMultiCode}
\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-col-unc-ps-trans}
\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-col-unc-ps-trans2}
\\
The next transformation is accomplished by utilising that \AgdaFunction{curry}
is an isomorphism with respect to \AgdaFunction{uncurry}, and that
\AgdaFunction{collapseToOne} is an isomorphism with respect to
\AgdaFunction{extendToOne}. With this \verb|g'| $\circ$ \verb|u| is obtained,
expanding \verb|g'|, \\
\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-col-unc-ps-trans2}
\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-g'-reduc}
\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-g'-reduc1}
\\
Before begin able to manipulate this expression the expression must be
reassociated. This is particularly tedious.\\

\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-g'-reduc1}
\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-reassoc}
\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-reassoc1}
\\
Once this has been achieved, definitions can be expanded and applied.
\AgdaFunction{$\delta$} is the unit of the diagonal-product adjunction and can
defined simply as \\
\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-delta} \\
Intuitively, it can be seen that the precomposition of a morphism by an arrow to
a product object can fused to push the precomposed morphism into each branch of
the product object.
\\
\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-reassoc1}
\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-in-u}
\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-in-u1} \\
To reproduce the original fixed point, $\phi$ should be composed with \verb|u|
followed by another composition with \verb|u|. To do this, a corollary to the
universal property of exponentials must be used, however some rearrangement must
be done. The corollary that needs to be used is \todo{eval-curry}

This requires considerably more work as each transformation of product
objects must be made explicit \\
\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-in-u1}
\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-product-rearr}
\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-product-rearr1} \\
One \verb|u| must be brought into the left-hand product without the right-hand
one in order to match the universal property of exponentials. Another
requirement for \AgdaFunction{eval-curry} is that $\phi$ $\circ$ \verb|u| must
be wrapped inside \AgdaFunction{curry}. This can be done by applying the
\AgdaFunction{curry∘uncurry} isomorphism \\
\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-product-rearr1}
\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-curryuncurry}
\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-curryuncurry1} \\
Now, the universal property can be applied to extract \AgdaFunction{uncurry}
($\phi$ $\circ$ \verb|u|) from the product object \\
\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-curryuncurry1}
\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-eval-curry}
\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-eval-curry1} \\
The end is in sight and all that remains is to extract the second \verb|u|. This
collapsing $A \times 1$ to $A$ which can be achieved by inserting the identity
for $A \times 1$ and deconstructing this into the morphisms comprising the
isomorphism and seeing what happens \\
\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-eval-curry1}
\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-ax1-iso}
\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-ax1-iso1} \\
The isomorphisms happen to precisecly be what is needed to recover the fixed
point \\
\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-ax1-iso1}
\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-iso-app}
\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-iso-app1} \\
Applying \AgdaFunction{projr} to the product object  extracts \verb|u| giving us
the fixed point \\
\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-proj-out}
\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-end} \\
The proof can be finished off by filling in the holes in the record \\
\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-record}
\end{AgdaMultiCode}

The contrapositive of the statement is worth defining as it is useful for some
of the applications.
\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-cantor}

\section{Applications}

Lawvere's fixed point theorem is an incredibly broad ranging theorem that
generalises many important theorems in mathematical logic and foundational
computer science and mathematics. This thesis will formalise and axiomatise two
specific instances, Cantor's diagonal argument and the first recursion theorem
in the $\lambda$-calculus. An analog to Cantor's diagonal argument will be introduced
alongside a category of small types in place of the category of sets.
After, categorical models of the $\lambda$-calculus will be explored and the
consequences of lawvere's fixed point theorem in these models. This theorem has
many more applications in paradoxes and logic which can be found in (Yanofsky).
Some limitations in formalising these within theorem provers will be explored in
the further work section.
\section{Cantor's Theorem}
An analogue of Cantor's theorem can be constructed using a category of small
types (i.e. all types that belong to a given universe).


A category can be constructed from the elements of any Agda universe of a
particular level.

\ExecuteMetaData[../agda/latex/ThesisSets.tex]{sets-instance}

The objects of the category are the types at the specified level. The morphisms
are the functions between types of this level. Equality of morphisms is
extensional propositional equality for functions. Morphism composition is
function composition, identity morphsism are identity functions. The axioms of
categories come simply from the definition of propositional equality.

\ExecuteMetaData[../agda/latex/ThesisSets.tex]{sets-equality}

Each instance of \AgdaDatatype{Sets} forms a cartesian closed categories.
Working with the lowest level universe.

\ExecuteMetaData[../agda/latex/ThesisCantor.tex]{cantor-univ}

Products correspond to the pair type

\ExecuteMetaData[../agda/latex/ThesisCantor.tex]{cantor-pair}

With the indexed family of projections being the projections out of the pair.

\ExecuteMetaData[../agda/latex/ThesisCantor.tex]{cantor-proj}

All that remains is to prove that these constitute the product object i.e. that
for each pair of arrows from a type to each component of the pair there exists a
(extensionally propositionally) unique function from the type to the pair object.

\ExecuteMetaData[../agda/latex/ThesisCantor.tex]{cantor-unique-type}

Given the indexed-family the unique arrow \verb|u| can be produced by extracting
the values from the indexed family and creating a pair from them

\ExecuteMetaData[../agda/latex/ThesisCantor.tex]{cantor-unique-def}

Where \todo{consturcot} is the constructor for a univeral mapping.

The next field of the universal mapping type is the proof that the provided
arrow satisfies the definition required from the product i.e.

\ExecuteMetaData[../agda/latex/ThesisCantor.tex]{cantor-proj-sat}

or in straightforward mathematical terms that the constructed arrow, \verb|u|,
satisfies with abuse of notation,
\begin{align*}
    \pi_{1} \circ \texttt{u} = f \land \pi_{2} \circ \texttt{u} = g
\end{align*}

where $f$ and $g$ are the two morphisms underlying \verb|p|. This proves to be
trivially true given the definition of \AgdaFunction{proj-pair}.

\ExecuteMetaData[../agda/latex/ThesisCantor.tex]{cantor-unique-def1}

The final field of the univeral mapping constructor is the proof that \verb|u|
is unique i .e. that for any \verb|g|\todo{type} such that \verb|g| satisfies
\AgdaFunction{proj-sat-univ} it is (extensionally) equal to \verb|u| or as a
type

\ExecuteMetaData[../agda/latex/ThesisCantor.tex]{cantor-unique}

The condition \verb|h|, equates \verb|g| to \todo{projpair}. This condition is
something that the unique arrow satisfies by definition. Using the transitivity
of equality 
productsproductsproducst

For a category to have finite products it must also have a terminal object. The
terminal object in the category \AgdaDatatype{Sets1} is the unit type

\ExecuteMetaData[../agda/latex/ThesisUnit.tex]{unit-unit}

To prove that \todo{here} is in fact the terminal object the universal property
must be proven

\ExecuteMetaData[../agda/latex/ThesisCantor.tex]{cantor-terminal-prop1}

This is a universal mapping property. The first argument to the constructor is
the unique arrow and the last the proof of uniqueness. The middle argument
ordinarily corresponds to the property the arrow must satisfy but the property
here is existence and so can be inferred automatically using an underscore as it
is trivially true if the type can be inhabited.

For a given type the function to the terminal object is the function that
constantly returns the single inhabitant of \todo{here}.

\ExecuteMetaData[../agda/latex/ThesisCantor.tex]{cantor-terminal-arrow}

The final component of the terminal object is the proof of uniqueness i.e. that
every function from a type to the terminal object is propositionally
(extensionally) equal. This
is trivially true as there is a single inhabitant of the unit type and therefore
only one place for to which all functions can map.

\ExecuteMetaData[../agda/latex/ThesisCantor.tex]{cantor-terminal-unique}

With this the universal mapping property can be completed

\todo{fix this}
\ExecuteMetaData[../agda/latex/ThesisCantor.tex]{cantor-terminal-prop2}

And it can be established that \AgdaDatatype{Sets1} has a terminal object

\ExecuteMetaData[../agda/latex/ThesisCantor.tex]{cantor-tisterminal}


The last requirement for a cartesian closed category is exponentials. For every
pair of types an exponential object must be produced consisting of a type, an
evaluation map and transposition (currying). The exponential object for two
types \verb|A| and \verb|B| is the function type between the two 

\ExecuteMetaData[../agda/latex/ThesisCantor.tex]{cantor-exponential}

The evaluation map takes a pair containing a function from a type \verb|A| to a
type \verb|B| and term of type \verb|A| and returns a \verb|B|. All that is
required here is to unpack the pair and apply the function to the value.

\ExecuteMetaData[../agda/latex/ThesisCantor.tex]{cantor-eval}




exponentials


ccc

not fixed point

cantor
\section{The $\lambda$-Calculus}
\todo{lambda equun theory}
There is much to suggest that a coherent interpretation of Lawvere's theorem
exists in the $\lambda$-calculus. The untyped $\lambda$-calculus is famous for
Curry's fixed point combinator \todo{combinator} of which a consequence is that
every $\lambda$-term has a fixed point under application (known as the first
fixed point theorem) indicating that perhaps a direct
application in an appropriate category could yield this result. In addition to
this, significant results in different models of computation are given as a
result as outlined in \todo{contextual background}. This observation has not
gone unnoticed by others. \verb|nLab| \todo{cite}, an online encyclopedia
for category theory, its webpage for Lawvere's fixed point
theorem states in \textbf{Remark 2.6}.

\begin{displayquote}
\textit{Many applications of Lawvere’s fixed point theorem are in the form of negated
propositions, e.g., there is no surjection from a set to its power set, or
Peano arithmetic cannot prove its own consistency. However, there are positive
applications as well, e.g., it implies the existence of fixed-point combinators
in untyped lambda calculus.}
\end{displayquote}

This claim affirms the notion that Curry's fixed combinator could be derived as
an instance of Lawvere's theorem. Despite this remark, the realities of the
situation are not so simple. The \verb|nLab| page does not provide a source for
their remark and, within the literature, there are only informal proofs of this
claim. Upon further examination the informal proofs contain some inaccuracies
that result in them not being a true reflection of Lawvere's theorem in the
context of the untyped $\lambda$-calculus. The precise issues with the
previously presented proofs will be outlined in \todo{evaluation}. In this
thesis a precise account of the relationship indicated within
the remark on \verb|nLab| will be presented, which does not quite extend to establishing the
existence of fixed point combinators within the $\lambda$-calculus but the
result - the first fixed point theorem.

The proof that Lawvere's theorem implies the existence of fixed points for all
$\lambda$-terms rests on the observation first made by Dana Scott in his
development of domain theory, that $\lambda$-terms can be considered as objects
of the models but also as functions between $\lambda$-terms. This naturally
engenders a desire for some object $D$ that is isomorphic to $D^D$, the function
space on $D$. This is impossible for any set within a set theory that rejects
unrestricted comprehension. Dana Scott solved this by constructing an object
$D_{\infty}$ as a complete partial order \todo{here}. These
ideas were generalised by Koymans and Scott identifying that all models of the
$\lambda$-calculus arise from cartesian closed category with an object $D$ that
has a retraction to its own function space, known as a reflexive object.

\todo{name corollary}

The relationship between these constructions and Lawvere's theorem can be
understood by observing that in any $CCC$ with a reflexive object $D$ there is a
point surjective morphism from $D$ to $D^D$, precisely the retraction.
Formalising this in Agda first requires a formalisation of a reflexive object
and retractions. In an arbitrary category a retraction between two objects
\verb|A| and \verb|B| is

\ExecuteMetaData[../agda/latex/ThesisRetract.tex]{retract-def-retract}

i.e. A pair of arrows in both directions between \verb|A| and \verb|B| and a
proof that the composition of the two form the identity in a given direction.
A reflexive object is simply some object \verb|D| alongside a retraction,
\AgdaDatatype{Retract} \verb|D| $\verb|D|^{\verb|D|}$. Now the relevant
corollary to Lawvere's fixed point theorem can be stated precisely, working in a
CCC

\ExecuteMetaData[../agda/latex/ThesisY.tex]{Y-def-corollary}

The proof can be created by creating a point-surjective function from \verb|X|
to $\verb|X|^{\verb|X|}$ and applying the earlier proof of
\AgdaFunction{lawvere}. First, the retraction can be pattern matched on and
Lawvere introduced with the arrow from \verb|X| to $\verb|X|^{\verb|X|}$ with
only a proof of point surjectivity required.

\ExecuteMetaData[../agda/latex/ThesisY.tex]{Y-def-corollary-body}

With \verb|b| being a general point to $\verb|X|^{\verb|X|}$, a point to
\verb|X| needs to be provided alongside a proof that \verb|b| is the solution to
the obvious equation \todo{fill in equation}. The point to \verb|X| is found by
using the retraction. The proof of equality is simply achieved by exploiting the
definition of a retraction to collapse the identity.

\ExecuteMetaData[../agda/latex/ThesisY.tex]{Y-point-surjective}


The implications of this corollary can be understood from this excerpt from section
5 of Barendregt's \textit{The Lambda Calculus: Its Syntax and Semantics}
\cite{barendregt1992lambda} on
models.

\begin{displayquote}
\textit{"\ldots for the construction of a $\lambda$-calculus model it
is sufficient to have an object $D$ in a CCC such that $D^D$ is a retract of
$D$."}
\end{displayquote}

Baredregt's textbook is a useful resource for all work within this section. From
the above quote and the earlier corollary to Lawvere's theorem it can be
concluded that the categorical interpretation of every model of the
$\lambda$-calculus has an object with the fixed point property.

Models, in the model-theoretic sense, are helpful for exploring properties of
the $\lambda$-calculus that are not immediate from the equational theory and
syntax itself. Concrete models of the $\lambda$-calculus include \todo{concrete
models} but what it meant to be model of the $\lambda$-calculus was elusive
until \todo{koymans} where the notion of $\lambda$-algebra was introduced as the
class of structures corresponding to the $\lambda$-calculus.

The definition of $\lambda$-algebras are predicated on the definition of an
applicative structure. An applicative structure is a tuple $M = (A \, , \,
\bullet)$ where $A$ is a set and $\bullet$ is a binary operation on $A$.


A useful type of models to be considered are the class of syntactic models. A
syntactic applicative structure adds a method of intepreting terms in the
$\lambda$-calculus, elements of the set $\Lambda$, into the applicative
struture. In other words a syntactic applicative structure is a triple $M = (A
\, , \, \bullet \, , \, \llbracket \, \rrbracket)$ of an underlying set $A$, a
binary operation $\bullet : A \rightarrow A$ and a syntactical intepretation
function $\llbracket \, \rrbracket$. See Barendregt \todo{for a precise account}
for a precise definition of $\llbracket \, \, \rrbracket$ and an appropriate definition of
satisfaction, $\vDash$.

The constraint which turns a syntactic applicative structure, \textit{P}, into a
syntactic $\lambda$-algebra is
\begin{align*}
    \bm{\lambda} \vdash M = N \Rightarrow P \models \llbracket M \rrbracket = \llbracket N
    \rrbracket
\end{align*}

Or that every two $\lambda$-terms that are equal under $\bm{\lambda}$ are equal
under their intepretation within the $\lambda$-algebra. There is a close
relationship between $\lambda$-algebras and $CCCs$. Every $\lambda$-algebra can
be transformed into a $CCC$ with a reflexive object via a process known as the
\textit{Karoubi Envelope}.\todo{karoubi} Furthermore, every $CCC$ with a
reflexive object can be turned into a $\lambda$-algebra such that taking a
$\lambda$-algebra to a $CCC$ and back to $\lambda$-algebra again produces an
isomorphic $\lambda$-algebra. This indicates that every $\lambda$-algebra can
be obtained by a $CCC$ with a reflexive object. The results of \todo{turn into
theorem} can be interpreted in both directions of this transformation.
Intepreting within the context of the transformation from \textit{Karoubi
envelope} to CCC yields no sensical results and will be detailed in
\todo{appendix}. Interpreting in the other direction, however, is more useful.


A (locally small) $CCC$ with a reflexive object, $D$, with arrows $F : D
\rightarrow D^D$ and $G : D^D \rightarrow D$ can be turned into a
$\lambda$-algebra as follows. The underlying set of the $\lambda$-algebra are
the points to $D$, written $|D|$. The binary operation, $\star$, of the
generated $\lambda$-algebra that operates on points, $a$, $b$ to $D$ is as
follows:
\begin{align*}
    a \star b = eval \circ \langle \, F \times id \, \rangle \circ \langle a \,
    , \, b \,
    \rangle
\end{align*}

\todo{here} defines a semantic intepretation function for $\lambda$-terms for
which the triple of $( \, |D| \, , \, \star \, , \, \llbracket \rrbracket \,)$
is shown to be  a $\lambda$-algebra in.


With \todo{corollary} and the fact that the above transformation yields all
$\lambda$-models
fixed point theorem can be used to prove the first recursion theorem in every
$\lambda$-model. The proof proceeds as follows. In some cartesian closed
category with a point surjective arrow, \AgdaFunction{PS.arr}, the operation
constituting $\star$ in the generated $\lambda$-algebra can be written as
follows

\ExecuteMetaData[../agda/latex/ThesisExtra.tex]{extra-applicative-op}

Proving the first fixed point theorem in every $\lambda$-algebra amounts to
showing that the following type is inhabited
\ExecuteMetaData[../agda/latex/ThesisExtra.tex]{extra-ffpt}

Or that every point to the reflexive object has a fixed point under $\star$. To
prove this, the fixed point must be provided and a proof that it is a fixed
point. The fixed point can be constructed as follows beginning by precomposing the
point-surjective arrow with the given point to \verb|f|

\begin{AgdaMultiCode}
\ExecuteMetaData[../agda/latex/ThesisExtra.tex]{extra-x-def}
\\
This gives a point to $\texttt{D}^\texttt{D}$. This can be turned into a
endomorphism on \verb|D| as follows by passing it through two familiar
isomorphisms
\\
\ExecuteMetaData[../agda/latex/ThesisExtra.tex]{extra-x-isos}
\\
Lawvere's fixed point theorem can now be used to find a fixed point for
\verb|y|
\\
\ExecuteMetaData[../agda/latex/ThesisExtra.tex]{extra-x-law}
\\
The fixed point and proof can be extracted as follows
\\
\ExecuteMetaData[../agda/latex/ThesisExtra.tex]{extra-x-fix}
\\
\verb|fixedPoint| is the fixed point for $\star$. Now, it needs to be shown that
\verb|fixedPoint| is in fact a fixed point for \verb|f| under $\star$ i.e.
\\
\ExecuteMetaData[../agda/latex/ThesisExtra.tex]{extra-fix-proof}
The definition of $\star$ can be expanded to
\\
\ExecuteMetaData[../agda/latex/ThesisExtra.tex]{extra-expand-pre}
\ExecuteMetaData[../agda/latex/ThesisExtra.tex]{extra-expand}
\\
From this point the proof proceeds in a similar fashion to the proof of
lawvere's fixed point theorem. The key observation here is that any point to
\verb|X| can composed with \AgdaFunction{Ps.arr} to give a point to
$\texttt{X}^{\texttt{X}}$ which can be pushed through familiar isomorphisms to
give a endomorphism on \verb|X|. The application of the generated applicative
structure amounts to converting the left hand point of the operation into an
endomorphism and then composing with the right hand point.
\\
\ExecuteMetaData[../agda/latex/ThesisExtra.tex]{extra-bulk-proof}
\ExecuteMetaData[../agda/latex/ThesisExtra.tex]{extra-bulk-proof1}
\\
The right hand side of the outermost composition now matches the constructed
\verb|y| from earlier \\
\ExecuteMetaData[../agda/latex/ThesisExtra.tex]{extra-bulk-proof1}
\ExecuteMetaData[../agda/latex/ThesisExtra.tex]{extra-almost}
\ExecuteMetaData[../agda/latex/ThesisExtra.tex]{extra-almost1} \\
\verb|fixedPointProof| can now be applied to make use of lawvere's fixed point
theorem. \\
\ExecuteMetaData[../agda/latex/ThesisExtra.tex]{extra-almost1}
\ExecuteMetaData[../agda/latex/ThesisExtra.tex]{extra-end}
\end{AgdaMultiCode}

The above theorem shows that the syntactic applicative structure generated from
any CCC with a point surjective morphism has a fixed point theorem. The first
fixed point theorem can be recovered from the $\lambda$-calculus by considering
the syntactic term models. \todo{term models} have a two way implication.

The above proof raises further questions concerning categorical intepretations
of the untyped $\lambda$-calculus. $\lambda$-algebras are all the models that,
for their interpretation of $\lambda$-terms, satisfy the equations of
$\bm{\lambda}$. Other structures exist that aim to characterise all models for
which other equational theories hold of their intepretation of $\lambda$-terms.
For instance, $\lambda$-models are an extension of $\lambda$-algebras which also
satisfy the Meyer-Scott axiom of weak-extensionality. The class of CCCs that
give rise to the $\lambda$-models are those with a reflexive object but also
\textit{have enough points}. \todo{have enough points} Furthermore there are the
extensional $\lambda$-algebras that correspond the equational theory with the
satisfies the $\eta$ rule i.e.
\begin{align*} P \vDash \forall x (\lambda x . M
    x) = M
\end{align*}

The class of CCCs that give rise to these structures are those that \textit{have
enough points} but, instead of having a reflexive object $D$, instead have the
isomorphism $D \equiv D^{D}$.

Given that point surjectivity gives a fixed point theorem for any applicative
structure generated for it a natural question that arises is to what underlying
structure it might correspond. The notion is certainly weaker than that of
certainly weaker than that of a $\lambda$-algebra as the arrow from $D^{D}
\rightarrow D$ for a reflexive object is made use of when defining the semantic
intepretation function giving rise to $\lambda$-algebras. This thesis does not
provide a concrete answer to this question but provides some combinators that
are derivable in any applicative structure derived from a CCC with a point
surjective object. The derivations of the combinators will be presented
informally due to their similarity to the above derivations with formal proofs
being contained in the appendix.

These combinators utilise the fact that $a \star b =
\overline{uncurry \, (\varphi \circ a)} \circ b$. If  $a$ can be picked
then, any endomorphism on $D$ can be recovered. More precisely, for any $f:
D \rightarrow D$, this can be turned into a point to $D^D$ by pushing through
the other way in the $1 \times A \cong A$ isomorphism and exploiting the other
direction of the adjunction, here given the name curry i.e. $f' = curry \, (
\,\underline{f} \,) : 1 \rightarrow D^D$. The point-surjectivity of $\varphi$
can now be used to find the equivalent $u$ such that $\varphi \circ u = f'$.
Considering $u \star b$ for any $b$

\begin{align*}
    u \star b &= \overline{uncurry \, (\varphi \circ u \, )} \circ b \\
    &= \overline{uncurry \, ( \, f' \, ) } \circ b \\
    &= \overline{uncurry \, ( \, curry \, ( \, \underline{f} \, ) \, )} \circ b \\
    &= f \circ b
\end{align*}


A fairly easy combinator to construct is the identity combinator $\textbf{I} \, x =
x$ by taking $f$ in the above construction to be $id$ and calculating the
equivalent $u$.

Another useful combinator is the mockingbird or self-application operator,
$\textbf{M} x = x x$ by taking $f$ to be the following morphism of type $D
\rightarrow D$, $\textbf{M'} = eval \circ \langle \varphi \times id \rangle \circ
\delta$ and finding the equivalent $u$ and setting it to be \textbf{M}.

The final combinator a derivation is given for was found whilst attempting to
recover the \textbf{K} combinator and requires slightly more machinery.

Let $x = id : D \rightarrow D$, $y = curry \, ( \, \underline{x} \, ) : 1
\rightarrow D^D$ pick $z : 1 \rightarrow D$ s.t. $\varphi \circ z = y$ from the
point-surjectivity of $\varphi$ let $q = z \, \circ \, !_{D} : D \rightarrow D$
where $!_{D}$ is the terminal arrow from $D$. Taking $f$ as $q$ and deriving the
appropriate $u$ an interesting combinator is derived. Calling the appropriate
$u$, \textbf{F}

\begin{align*}
    \textbf{F} \star a \star b &= (\textbf{F} \circ a) \star b \\
    &= eval \circ \langle \varphi  \times id \rangle \circ \langle q \circ a , b
    \rangle \\
    &= eval \circ \langle \varphi \times id \rangle \circ \langle z \, \circ \, !_{D}
    \, \circ \, a , \, b \rangle \\
    &= eval \circ \langle \varphi \circ z \times id \rangle \circ \langle !_{D} \,
    \circ \, a \, , \, b \rangle \\
    &= \overline{uncurry \, ( \varphi \circ z \, )} \circ b \\
    &= id \circ b \\
    &= b
\end{align*}
i.e. \textbf{F} selects the second of its two arguments. With some work perhaps
more combinators could be derived and, potentially, they will form a complete
basis for combinatory logic. Even if not , it is interesting to understand to
which computational world point-surjectivity corresponds.
