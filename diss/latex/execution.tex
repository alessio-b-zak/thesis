% !TEX root = ./dissertation.tex
\section{Agda-fying Categories}

\subsection{Categories}

Categories can be constructed in Agda with relative simplicity. The initial
concepts introduced here are taken from \verb|cats|, a Category Theory library
in Agda by Jannis Limpberg. \AgdaBound{lo}, \AgdaBound{la} and \AgdaBound{l≈}
are used in the following section as variables of type \AgdaDatatype{Level}.

Categories can be introduced as a record parameterised by the level of their
objects, arrows and type of morphism equality respectively
\ExecuteMetaData[../agda/latex/ThesisCategory.tex]{cat-def}

Categories are typed at a level above the largest of objects, arrows and
equalities in order to present equality on morphisms as relations on types as
per the Agda standard library. The axioms of a category are presented as fields
of the record. Objects are permitted to be any type of any level and morphisms
typed as any function that takes two objects and returns a type.

Identity arrows and composition take their obvious definitions. The identity
arrow provides a distinguished morphism for each object implicitly and
composition is a function that takes two morphisms of the correct shape and
returns the appropriate morphism
\ExecuteMetaData[../agda/latex/ThesisCategory.tex]{cat-field-comp-id}

To codify the associativity of composition and the neutrality of identity it is
not practical to use propositional equality. Proving these as propositional
equalities of the structures that are often categorified is often a difficult
task. Propositional equality for a structure amounts to showing propositional
equality on its constituent components. That two terms are propositionally equal
implies the terms have the same normal form. There are often situations where it
is desirable to equate two different terms that do not have the same normal
forms. As an example, consider equating propositionally two monoid
homomorphisms. In a dependently typed setting this requires that the proofs of
preservation for the two morphisms are also equal in addition to the functions
between the underlying monoids. This is a tedious requirement that is often
undesired. \todo{Axiom K?}To remedy this, the earlier mentioned setoid model is
used whereby structures are equated by an equivalence relation.\todo{hott} For
categories an equivalence relation for morphism must be provided
\ExecuteMetaData[../agda/latex/ThesisCategory.tex]{cat-field-rel}

The \AgdaFunction{IsEquivalence} function establishes the appropriate proofs of
reflexivity, transitivity and symmetry.

With the notion of equality of morphisms in place it is possible to state the
properties of composition and identity

\ExecuteMetaData[../agda/latex/ThesisCategory.tex]{cat-field-comp}

The field \AgdaField{∘{-}resp} is a necessary and inconvenient aspect of
utilising equivalence relations over propositional equality. Preserves2
indicates that composition is congruent in both of its arguments. This allows us
to target individual compositions in a large categorical term to apply an
equality. This is given for free when using propositional equality as functions
are unable to distinguish terms with the same normal form. This can be seen as
one of the downsides to using equivalence relations as congruence must be proven
for every each individual equivalence relation.\todo{congruence}


\subsection{Uniqueness}

The next step in the categorical journey is a critical component of many of the
more complex abstractions, the notion of unique arrow

\ExecuteMetaData[../agda/latex/ThesisUnique.tex]{unique-def-unique}

Uniqueness is often given with respect to a property (hence universal
properties). In Agda this amounts to formulating the property as type
parameterised by the property and an arrow satisfying the property. The type
encodes a function which, given any other arrow satisfying the property
expresses equality to the parameterised arrow. Using this a general unique arrow
can be encoded using a trivial function that always returns the unit.

Universal properties can now be given as an object, a proposition and a proof of
uniqueness

\ExecuteMetaData[../agda/latex/ThesisUnique.tex]{unique-def-exun}

Agda's syntax directive can be used to create a universal property like type
\todo{syntax}, as in the characterisation of an object as terminal whereby an
object is terminal if, for any other object in the category, there is an arrow
from the object to the terminal alongside a proof of uniqueness.

\ExecuteMetaData[../agda/latex/ThesisUnique.tex]{unique-def-terminal}

A category having a terminal object can now be encoded as a proposition which
takes a category and provides an object alongside a proof that it is terminal

\ExecuteMetaData[../agda/latex/ThesisTerminal.tex]{terminal-def-has}

To prove Lawvere's Fixed Point Theorem within Agda and the various surrounding
proofs in logic, Cartesian Closed Categories must be formalised. For this, in
addition to terminal objects, binary products and exponentials will be needed

\ExecuteMetaData[../agda/latex/ThesisCCC.tex]{ccc-def-is-ccc}

Products and exponentials have slightly more involved definitions. Beginning
with the uniqueness principle for products

\ExecuteMetaData[../agda/latex/ThesisProduct.tex]{product-def-product}

\AgdaFunction{IsProduct} takes an indexing function, a product object, and some
projections out of the product into the components of the indexing
category. \AgdaFunction{IsProduct} returns a function type which, upon being
supplied a set of projections from an object to the indexing set, returns a
unique arrow from the the object to the previously supplied product object
satisfying the commuting diagrams for the product.


\subsection{Points}
All that follows is work done during this thesis. The theorem makes use of the
notion of points and some surrounding definitions

Points are a categorical abstraction that generalise the notion of elements of
a set. A point is an arrow from the terminal object to any other object

\ExecuteMetaData[../agda/latex/ThesisPoints.tex]{point-def-point}

Given the name of Lawvere's theorem it makes sense to formalise the notion of a
fixed point categorically

\ExecuteMetaData[../agda/latex/ThesisPoints.tex]{point-def-fixed-point}

A fixed point of a morphism is a point that is idempotent under composition to
the right with the morphism. As is common within the \verb|cats| library this is
then wrapped up in a record as a sigma type to express that a given function has
a fixed point

\ExecuteMetaData[../agda/latex/ThesisPoints.tex]{point-def-has-fixed-point}

Now the fixed point property which features in Lawvere's theorem can be
formalised which is a predicate on a object in a category expressing that all
endomorphisms on the object have a fixed point.

\ExecuteMetaData[../agda/latex/ThesisPoints.tex]{point-def-fixed-point-property}
 on the object have a fixed point.

Another useful feature in lawvere's theorem is the notion of point surjectivity
which itself requires some machinery. First the notion of a solved equation with
points

\ExecuteMetaData[../agda/latex/ThesisPoints.tex]{point-def-solution}

Point surjectivity expresses the notion that given a point to $B$, $b : 1
\rightarrow B$, and a morphism $f : A \rightarrow B$, we can produce a point to
$A$, $a : 1 \rightarrow A$, that satisfies the equation $f \circ a = b$.

Packaging this up into a sigma type which, given a morphism from an object A to
an object B and a point to B contains a point to A and a proof that is
constitutes a solution to the triple.

\ExecuteMetaData[../agda/latex/ThesisPoints.tex]{point-def-has-solution}

A point surjective morphism is a function for which every point to B there
exists a solution

\ExecuteMetaData[../agda/latex/ThesisPoints.tex]{point-def-is-point-surjective}

The formulation of the point surjectivity used in the theorem as a record
confirming the existence of a point surjective function between two objects

\ExecuteMetaData[../agda/latex/ThesisPoints.tex]{point-def-point-surjective}

\subsection{Lawvere's Fixed Point Theorem}

It is now possible to state Lawvere's theorem precisely, working within a
Cartesian Closed Category.

\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-type-diagonal}

Or mathematically that in a Cartesian Closed Category, given a point-surjective
function from some object $A$ to the exponential object, $B^A$, from $A$ to some object
$B$, every endomorphism on $B$ has a fixed point.

The proof of the theorem will be developed line by line. The first step is to
pattern match on the arguments to the proof and bring in the constructors for
the output type.

\begin{AgdaMultiCode}
\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-pattern}
\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-pattern-end}
\end{AgdaMultiCode}

The first argument to the proof is the point-surjective morphism constituting
the morphism and the proof of point-surjectivity, and the second argument is the
endomorphism on \verb|B|. The output, a record with holes, requires a point to
\verb|B| alongside a proof that it is a fixed point of \verb|f|.

To produce a fixed-point the goal is to create a morphism, \verb|g|,  from \verb|A| to
\verb|B| and then exploit the point-surjective morphism to find a point to
\verb|A|. With the correctly chosen \verb|g| the composition of this point to A
with \verb|g| will be a fixed-point. \verb|g| will be constructed such that is
in some way "self-replicating".

\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-h-def}

Categorically, \verb|g| represents the following diagram

\[\begin{tikzcd}[sep=huge]
    B & B \arrow[l, "f"] & B^A \times A \arrow[l, "eval"] & A \times A \arrow[l,
    "{\langle \phi \, , id\rangle}"] & A \arrow[l, "\delta"]
\end{tikzcd}\]

In order to push \verb|g| morphism back through the point-surjective morphism
it needs to be turned into a point to the exponential object. This can be
achieved via two isomorphisms, $1 \times A \cong A$ and $hom(A \times B \: , \, C)
\cong hom(A \: , \, C^B)$, the types and directions that are used proof as
follows

\begin{AgdaMultiCode}
\ExecuteMetaData[../agda/latex/ThesisExtension.tex]{extension-types-collapseToOne}
\ExecuteMetaData[../agda/latex/ThesisTypes.tex]{types-type-curry}
\end{AgdaMultiCode}

By applying the first isomorphism followed by the second, a point to $B^A$ can
be acquired
\begin{AgdaAlign}
\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-g'-def}

The point-surjectivity of $\phi$ can now be used to acquire the associated point
to \verb|A| with \verb|g'|

\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-ps-def}
\end{AgdaAlign}

The fixed point construction can now be achieved by composing $\phi$ with
\verb|u| twice to obtain a point to \verb|B|. After composing once with \verb|u|
a point to $B^A$ is obtained. This must be pushed through the aformentioned
isomorphisms to get a morphism, $A \rightarrow B$, to compose with \verb|u|
again.

\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-isos-proof}

Now it must be shown that \verb|f| $\circ$ \verb|fixedPoint| $\approx$
\verb|fixedPoint|. This proof will be developed using equational reasoning. The
proof starts with the word \AgdaFunction{begin} and the left-hand side of the
equality, with expressions separated by
equalities on morphisms, put inside
\AgdaOperator{\AgdaFunction{≈⟨}}\AgdaSpace{}\AgdaOperator{\AgdaFunction{⟩}}, and
ends with the right-hand side of the equality followed by
\AgdaOperator{\AgdaFunction{∎}}. In the case of the required proof

\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-fix-proof}

The first transformation in the proof is to use the point-surjectivity of
$\phi$ to expand the the $\phi$ $\circ$ \verb|u| within the definition of
\verb|fixedPoint| to \verb|g'|.

The proof of point-surjectivity is extracted as follows

\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-ps-proof}

This cannot be used directly due to the application of \AgdaFunction{curry} and
\AgdaFunction{extendToOne} to the expression. The usage of equivlance relations
means that congruence must be proved separately for every function on
morphisms. These two proofs have the following types but the proofs are elided
due to unecessary complexity.

\begin{AgdaSuppressSpace}
\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-uncurry-resp-prf}
\ExecuteMetaData[../agda/latex/ThesisExtension.tex]{extension-coll21-r-type}
\end{AgdaSuppressSpace}

To make \verb|ps-proof| work within the nested function applications they are
wrapped in the two proofs of congruence necessary

\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-col-unc-ps}

This can then be used by targeting the lefthand morphism of the outermost
composition and change this to \verb|g'|

\begin{AgdaMultiCode}
\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-col-unc-ps-trans}
\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-col-unc-ps-trans2}
\end{AgdaMultiCode}

The next transformation is accomplished by utilising that \AgdaFunction{curry}
is an isomorphism with respect to \AgdaFunction{uncurry}, and that
\AgdaFunction{collapseToOne} is an isomorphism with respect to
\AgdaFunction{extendToOne}. With this \verb|g'| $\circ$ \verb|u| is obtained,
expanding \verb|g'|, \\
\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-col-unc-ps-trans2}
\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-g'-reduc}
\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-g'-reduc1}
\\
Before begin able to manipulate this expression the expression must be
reassociated. This is particularly tedious.\\

\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-g'-reduc1}
\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-reassoc}
\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-reassoc1}
\\
Once this has been achieved, definitions can be expanded and applied.
\AgdaFunction{$\delta$} is the unit of the diagonal-product adjunction and can
defined simply as \\
\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-delta} \\
Intuitively, it can be seen that the precomposition of a morphism by an arrow to
a product object can fused to push the precomposed morphism into each branch of
the product object.
\\
\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-reassoc1}
\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-in-u}
\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-in-u1} \\
To reproduce the original fixed point, $\phi$ should be composed with \verb|u|
followed by another composition with \verb|u|. To do this, a corollary to the
universal property of exponentials must be used, however some rearrangement must
be done. The corollary that needs to be used is \todo{eval-curry}

This requires considerably more work as each transformation of product
objects must be made explicit \\
\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-in-u1}
\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-product-rearr}
\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-product-rearr1} \\
One \verb|u| must be brought into the left-hand product without the right-hand
one in order to match the universal property of exponentials. Another
requirement for \AgdaFunction{eval-curry} is that $\phi$ $\circ$ \verb|u| must
be wrapped inside \AgdaFunction{curry}. This can be done by applying the
\AgdaFunction{curry∘uncurry} isomorphism \\
\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-product-rearr1}
\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-curryuncurry}
\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-curryuncurry1} \\
Now, the universal property can be applied to extract \AgdaFunction{uncurry}
($\phi$ $\circ$ \verb|u|) from the product object \\
\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-curryuncurry1}
\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-eval-curry}
\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-eval-curry1} \\
The end is in sight and all that remains is to extract the second \verb|u|. This
collapsing $A \times 1$ to $A$ which can be achieved by inserting the identity
for $A \times 1$ and deconstructing this into the morphisms comprising the
isomorphism and seeing what happens \\
\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-eval-curry1}
\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-ax1-iso}
\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-ax1-iso1} \\
The isomorphisms happen to precisecly be what is needed to recover the fixed
point \\
\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-ax1-iso1}
\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-iso-app}
\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-iso-app1} \\
Applying \AgdaFunction{projr} to the product object  extracts \verb|u| giving us
the fixed point \\
\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-proj-out}
\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-end} \\
The proof can be finished off by filling in the holes in the record \\
\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-record}
\end{AgdaMultiCode}

The contrapositive of the statement is worth defining as it is useful for some
of the applications.
\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-cantor}

\subsection{Applications}

Lawvere's fixed point theorem is an incredibly broad ranging theorem that
generalises many important theorems in mathematical logic and foundational
computer science and mathematics. This thesis will formalise and axiomatise two
specific instances, Cantor's diagonal argument and the first recursion theorem
in the $\lambda$-calculus. An analog to Cantor's diagonal argument will be introduced
alongside a category of small types in place of the category of sets.
After, categorical models of the $\lambda$-calculus will be explored and the
consequences of lawvere's fixed point theorem in these models. This theorem has
many more applications in paradoxes and logic which can be found in (Yanofsky).
Some limitations in formalising these within theorem provers will be explored in
the further work section.
\subsection{Cantor's Diagonal Theorem}

\subsection{The $\lambda$-Calculus}

Despite the deep connection between CCCs and the $\lambda$-calculus \todo{cite}
Lawvere's fixed point theorem has been relatively underexplored within the
field. In this section, a focus will be placed on the untyped
$\lambda$-calculus. A common theme in presentations of Lawvere's fixed point
theorem is the statement to the effect that the theorem allows for the
derivation of a fixed point combinator for the untyped $\lambda$-calculus.
Whilst being a claim repeated in several papers there does not appear to be a
proof associated with this. In contrast it is somewhat easier to find a proof
of the first fixed point theorem in the untyped $\lambda$-calculus. \todo{theorem}

In this thesis provide a novel proof is provided of the first fixed point
theorem using Lawvere's fixed point theorem. A simpler proof is also provided.
The proof in this thesis outlines an interesting phenomena and poses some
questions in the study of models of the $\lambda$-calculus. Both proofs rest on
a similar and simple observations of models of the $\lambda$-calculus and a
simple corollary of Lawvere's fixed point theorem. The observation in the
theory of the untyped $\lambda$-calculus, first made by Dana Scott in his
development of domain theory, is that models for the $\lambda$-calculus often
want to exploit the fact that $\lambda$-terms can be considered as objects of
the models but that $\lambda$-terms themselves are functions between
$\lambda$-terms. This naturally engenders a desire for some object $D$ that is
isomorphic to $D^D$, the function space on $D$. This is impossible for any set,
as shown by the previous section. Dana Scott solved this by constructing an
object $D_{\infty}$ as a complete partial order which will be outlined below.
This was later generalised by Koymans and Scott to be any Cartesian closed
category with an object $D$ which has a retraction to its own function space,
termed as a reflexive object.

The relationship between these constructions and Lawvere's theorem can be
understood by observing that in any CCC with a reflexive object $D$ there is a
point surjective morphism from $D$ to $D^D$, precisely the retraction.
Formalising this in Agda first requires a formalisation of a reflexive object
and retractions. In an arbitrary category a retraction between two objects
\verb|A| and \verb|B| is

\ExecuteMetaData[../agda/latex/ThesisRetract.tex]{retract-def-retract}

i.e. A pair of arrows in both directions between \verb|A| and \verb|B| and a
proof that the composition of the two form the identity in a given direction.
A reflexive object is simply some object \verb|D| alongside a retraction,
\AgdaDatatype{Retract} \verb|D| $\verb|D|^{\verb|D|}$. Now the relevant
corollary to Lawvere's fixed point theorem can be stated precisely, working in a
CCC

\ExecuteMetaData[../agda/latex/ThesisY.tex]{Y-def-corollary}

Understanding what this means requires looking at the specific of both models in
detail. First however what exactly it means to be a model of the
$\lambda$-calculus in general.
\\
- $\lambda$-models \\
- syntactic lambda models \\
- $D_{\infty}$ as a lambda model and a category. Fixed point derivation \\
- CCCs with a reflexive object Karoubi and reverse. Derivation of fixed point
combinator for first direction. Discussion of point surjective and what models
they correspond to. Potential future work.
