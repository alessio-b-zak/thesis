% !TEX root = ./dissertation.tex
\section{Agda-fying Categories}

\subsection{Categories}

Categories can be constructed in Agda with relative simplicity. The initial
concepts introduced here are taken from \verb|cats|, a Category Theory library
in Agda by Jannis Limpberg. \AgdaBound{lo}, \AgdaBound{la} and \AgdaBound{l≈}
are used in the following section as variables of type \AgdaDatatype{Level}.

Categories can be introduced as a record parameterised by the level of their
objects, arrows and type of morphism equality respectively
\ExecuteMetaData[../agda/latex/ThesisCategory.tex]{cat-def}

Categories are typed at a level above the largest of objects, arrows and
equalities in order to present equality on morphisms as relations on types as
per the Agda standard library. The axioms of a category are presented as fields
of the record. Objects are permitted to be any type of any level and morphisms
typed as any function that takes two objects and returns a type.

Identity arrows and composition take their obvious definitions. The identity
arrow provides a distinguished morphism for each object implicitly and
composition is a function that takes two morphisms of the correct shape and
returns the appropriate morphism
\ExecuteMetaData[../agda/latex/ThesisCategory.tex]{cat-field-comp-id}

To codify the associativity of composition and the neutrality of identity it is
not practical to use propositional equality. Proving these as propositional
equalities of the structures that are often categorified is often a difficult
task. Propositional equality for a structure amounts to showing propositional
equality on its constituent components. That two terms are propositionally equal
implies the terms have the same normal form. There are often situations where it
is desirable to equate two different terms that do not have the same normal
forms. As an example, consider equating propositionally two monoid
homomorphisms. In a dependently typed setting this requires that the proofs of
preservation for the two morphisms are also equal in addition to the functions
between the underlying monoids. This is a tedious requirement that is often
undesired. \todo{Axiom K?}To remedy this, the earlier mentioned setoid model is
used whereby structures are equated by an equivalence relation.\todo{hott} For
categories an equivalence relation for morphism must be provided
\ExecuteMetaData[../agda/latex/ThesisCategory.tex]{cat-field-rel}

The \AgdaFunction{IsEquivalence} function establishes the appropriate proofs of
reflexivity, transitivity and symmetry.

With the notion of equality of morphisms in place it is possible to state the
properties of composition and identity

\ExecuteMetaData[../agda/latex/ThesisCategory.tex]{cat-field-comp}

The field \AgdaField{∘{-}resp} is a necessary and inconvenient aspect of
utilising equivalence relations over propositional equality. Preserves2
indicates that composition is congruent in both of its arguments. This allows us
to target individual compositions in a large categorical term to apply an
equality. This is given for free when using propositional equality as functions
are unable to distinguish terms with the same normal form. This can be seen as
one of the downsides to using equivalence relations as congruence must be proven
for every each individual equivalence relation.\todo{congruence}


\subsection{Uniqueness}

The next step in the categorical journey is a critical component of many of the
more complex abstractions, the notion of unique arrow

\ExecuteMetaData[../agda/latex/ThesisUnique.tex]{unique-def-unique}

Uniqueness is often given with respect to a property (hence universal
properties). In Agda this amounts to formulating the property as type
parameterised by the property and an arrow satisfying the property. The type
encodes a function which, given any other arrow satisfying the property
expresses equality to the parameterised arrow. Using this a general unique arrow
can be encoded using a trivial function that always returns the unit.

Universal properties can now be given as an object, a proposition and a proof of
uniqueness

\ExecuteMetaData[../agda/latex/ThesisUnique.tex]{unique-def-exun}

Agda's syntax directive can be used to create a universal property like type
\todo{syntax}, as in the characterisation of an object as terminal whereby an
object is terminal if, for any other object in the category, there is an arrow
from the object to the terminal alongside a proof of uniqueness.

\ExecuteMetaData[../agda/latex/ThesisUnique.tex]{unique-def-terminal}

A category having a terminal object can now be encoded as a proposition which
takes a category and provides an object alongside a proof that it is terminal

\ExecuteMetaData[../agda/latex/ThesisTerminal.tex]{terminal-def-has}

To prove Lawvere's Fixed Point Theorem within Agda and the various surrounding
proofs in logic, Cartesian Closed Categories must be formalised. For this, in
addition to terminal objects, binary products and exponentials will be needed

\ExecuteMetaData[../agda/latex/ThesisCCC.tex]{ccc-def-is-ccc}

Products and exponentials have slightly more involved definitions. Beginning
with the uniqueness principle for products

\ExecuteMetaData[../agda/latex/ThesisProduct.tex]{product-def-product}

\AgdaFunction{IsProduct} takes an indexing function, a product object, and some
projections out of the product into the components of the indexing
category. \AgdaFunction{IsProduct} returns a function type which, upon being
supplied a set of projections from an object to the indexing set, returns a
unique arrow from the the object to the previously supplied product object
satisfying the commuting diagrams for the product.


\subsection{Points} \todo{expand proofs further}
All that follows is work done during this thesis. The theorem makes use of the
notion of points and some surrounding definitions

Points are a categorical abstraction that generalise the notion of elements of
a set. A point is an arrow from the terminal object to any other object

\ExecuteMetaData[../agda/latex/ThesisPoints.tex]{point-def-point}

Given the name of Lawvere's theorem it makes sense to formalise the notion of a
fixed point categorically

\ExecuteMetaData[../agda/latex/ThesisPoints.tex]{point-def-fixed-point}

A fixed point of a morphism is a point that is idempotent under composition to
the right with the morphism. As is common within the \verb|cats| library this is
then wrapped up in a record as a sigma type to express that a given function has
a fixed point

\ExecuteMetaData[../agda/latex/ThesisPoints.tex]{point-def-has-fixed-point}

Now the fixed point property which features in Lawvere's theorem can be
formalised which is a predicate on a object in a category expressing that all
endomorphisms on the object have a fixed point.

\ExecuteMetaData[../agda/latex/ThesisPoints.tex]{point-def-fixed-point-property}
 on the object have a fixed point.

Another useful feature in lawvere's theorem is the notion of point surjectivity
which itself requires some machinery. First the notion of a solved equation with
points

\ExecuteMetaData[../agda/latex/ThesisPoints.tex]{point-def-solution}

Point surjectivity expresses the notion that given a point to $B$, $b : 1
\rightarrow B$, and a morphism $f : A \rightarrow B$, we can produce a point to
$A$, $a : 1 \rightarrow A$, that satisfies the equation $f \circ a = b$.

Packaging this up into a sigma type which, given a morphism from an object A to
an object B and a point to B contains a point to A and a proof that is
constitutes a solution to the triple.

\ExecuteMetaData[../agda/latex/ThesisPoints.tex]{point-def-has-solution}

A point surjective morphism is a function for which every point to B there
exists a solution

\ExecuteMetaData[../agda/latex/ThesisPoints.tex]{point-def-is-point-surjective}

The formulation of the point surjectivity used in the theorem as a record
confirming the existence of a point surjective function between two objects

\ExecuteMetaData[../agda/latex/ThesisPoints.tex]{point-def-point-surjective}

\section{Lawvere's Fixed Point Theorem}

It is now possible to state Lawvere's theorem precisely, working within a
Cartesian Closed Category.

\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-type-diagonal}

Or mathematically that in a Cartesian Closed Category, given a point-surjective
function from some object $A$ to the exponential object, $B^A$, from $A$ to some object
$B$, every endomorphism on $B$ has a fixed point.

The proof of the theorem will be developed line by line. The first step is to
pattern match on the arguments to the proof and bring in the constructors for
the output type.

\begin{AgdaMultiCode}
\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-pattern}
\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-pattern-end}
\end{AgdaMultiCode}

The first argument to the proof is the point-surjective morphism constituting
the morphism and the proof of point-surjectivity, and the second argument is the
endomorphism on \verb|B|. The output, a record with holes, requires a point to
\verb|B| alongside a proof that it is a fixed point of \verb|f|.

To produce a fixed-point the goal is to create a morphism, \verb|g|,  from \verb|A| to
\verb|B| and then exploit the point-surjective morphism to find a point to
\verb|A|. With the correctly chosen \verb|g| the composition of this point to A
with \verb|g| will be a fixed-point. \verb|g| will be constructed such that is
in some way "self-replicating".

\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-h-def}

Categorically, \verb|g| represents the following diagram

\[\begin{tikzcd}[sep=huge]
    B & B \arrow[l, "f"] & B^A \times A \arrow[l, "eval"] & A \times A \arrow[l,
    "{\langle \phi \, , id\rangle}"] & A \arrow[l, "\delta"]
\end{tikzcd}\]

In order to push \verb|g| morphism back through the point-surjective morphism
it needs to be turned into a point to the exponential object. This can be
achieved via two isomorphisms, $1 \times A \cong A$ and $\textnormal{hom}(A \times B \: , \, C)
\cong \textnormal{hom}(A \: , \, C^B)$, the types and directions that are used proof as
follows

\begin{AgdaMultiCode}
\ExecuteMetaData[../agda/latex/ThesisExtension.tex]{extension-types-collapseToOne}
\ExecuteMetaData[../agda/latex/ThesisTypes.tex]{types-type-curry}
\end{AgdaMultiCode}

By applying the first isomorphism followed by the second, a point to $B^A$ can
be acquired
\begin{AgdaAlign}
\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-g'-def}

The point-surjectivity of $\phi$ can now be used to acquire the associated point
to \verb|A| with \verb|g'|

\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-ps-def}
\end{AgdaAlign}

The fixed point construction can now be achieved by composing $\phi$ with
\verb|u| twice to obtain a point to \verb|B|. After composing once with \verb|u|
a point to $B^A$ is obtained. This must be pushed through the aformentioned
isomorphisms to get a morphism, $A \rightarrow B$, to compose with \verb|u|
again.

\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-isos-proof}

Now it must be shown that \verb|f| $\circ$ \verb|fixedPoint| $\approx$
\verb|fixedPoint|. This proof will be developed using equational reasoning. The
proof starts with the word \AgdaFunction{begin} and the left-hand side of the
equality, with expressions separated by
equalities on morphisms, put inside
\AgdaOperator{\AgdaFunction{≈⟨}}\AgdaSpace{}\AgdaOperator{\AgdaFunction{⟩}}, and
ends with the right-hand side of the equality followed by
\AgdaOperator{\AgdaFunction{∎}}. In the case of the required proof

\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-fix-proof}

The first transformation in the proof is to use the point-surjectivity of
$\phi$ to expand the the $\phi$ $\circ$ \verb|u| within the definition of
\verb|fixedPoint| to \verb|g'|.

The proof of point-surjectivity is extracted as follows

\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-ps-proof}

This cannot be used directly due to the application of \AgdaFunction{curry} and
\AgdaFunction{extendToOne} to the expression. The usage of equivlance relations
means that congruence must be proved separately for every function on
morphisms. These two proofs have the following types but the proofs are elided
due to unecessary complexity.

\begin{AgdaSuppressSpace}
\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-uncurry-resp-prf}
\ExecuteMetaData[../agda/latex/ThesisExtension.tex]{extension-coll21-r-type}
\end{AgdaSuppressSpace}

To make \verb|ps-proof| work within the nested function applications they are
wrapped in the two proofs of congruence necessary

\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-col-unc-ps}

This can then be used by targeting the lefthand morphism of the outermost
composition and change this to \verb|g'|. This is done using
\AgdaFunction{∘-resp-l} which allows a proof to be applied to chang the lefthand
side of a morphism composition.

\begin{AgdaMultiCode}
\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-col-unc-ps-trans}
\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-col-unc-ps-trans2}
\\
The next transformation is accomplished by utilising that \AgdaFunction{curry}
is an isomorphism with respect to \AgdaFunction{uncurry}, and that
\AgdaFunction{collapseToOne} is an isomorphism with respect to
\AgdaFunction{extendToOne}. With this \verb|g'| $\circ$ \verb|u| is obtained,
expanding \verb|g'|, \\
\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-col-unc-ps-trans2}
\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-g'-reduc}
\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-g'-reduc1}
\\
Before begin able to manipulate this expression the expression must be
reassociated. This is particularly tedious.\\

\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-g'-reduc1}
\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-reassoc}
\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-reassoc1}
\\
Once this has been achieved, definitions can be expanded and applied.
\AgdaFunction{$\delta$} is the unit of the diagonal-product adjunction and can
defined simply as \\
\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-delta} \\
Intuitively, it can be seen that the precomposition of a morphism by an arrow to
a product object can fused to push the precomposed morphism into each branch of
the product object.
\\
\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-reassoc1}
\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-in-u}
\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-in-u1} \\
To reproduce the original fixed point, $\phi$ should be composed with \verb|u|
followed by another composition with \verb|u|. To do this, a corollary to the
universal property of exponentials must be used, however some rearrangement must
be done. The corollary that needs to be used is \todo{eval-curry}

This requires considerably more work as each transformation of product
objects must be made explicit \\
\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-in-u1}
\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-product-rearr}
\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-product-rearr1} \\
One \verb|u| must be brought into the left-hand product without the right-hand
one in order to match the universal property of exponentials. Another
requirement for \AgdaFunction{eval-curry} is that $\phi$ $\circ$ \verb|u| must
be wrapped inside \AgdaFunction{curry}. This can be done by applying the
\AgdaFunction{curry∘uncurry} isomorphism \\
\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-product-rearr1}
\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-curryuncurry}
\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-curryuncurry1} \\
Now, the universal property can be applied to extract \AgdaFunction{uncurry}
($\phi$ $\circ$ \verb|u|) from the product object \\
\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-curryuncurry1}
\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-eval-curry}
\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-eval-curry1} \\
The end is in sight and all that remains is to extract the second \verb|u|. This
collapsing $A \times 1$ to $A$ which can be achieved by inserting the identity
for $A \times 1$ and deconstructing this into the morphisms comprising the
isomorphism and seeing what happens \\
\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-eval-curry1}
\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-ax1-iso}
\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-ax1-iso1} \\
The isomorphisms happen to precisecly be what is needed to recover the fixed
point \\
\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-ax1-iso1}
\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-iso-app}
\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-iso-app1} \\
Applying \AgdaFunction{projr} to the product object  extracts \verb|u| giving us
the fixed point \\
\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-proj-out}
\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-end} \\
The proof can be finished off by filling in the holes in the record \\
\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-record}
\end{AgdaMultiCode}

The contrapositive of the statement is worth defining as it is useful for some
of the applications.
\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-cantor}

\section{Applications}

Lawvere's fixed point theorem is an incredibly broad ranging theorem that
generalises many important theorems in mathematical logic and foundational
computer science and mathematics. This thesis will formalise and axiomatise two
specific instances, Cantor's diagonal argument and the first recursion theorem
in the $\lambda$-calculus. An analog to Cantor's diagonal argument will be introduced
alongside a category of small types in place of the category of sets.
After, categorical models of the $\lambda$-calculus will be explored and the
consequences of lawvere's fixed point theorem in these models. This theorem has
many more applications in paradoxes and logic which can be found in (Yanofsky).
Some limitations in formalising these within theorem provers will be explored in
the further work section.
\section{Cantor's Theorem}
\section{Russell's Paradox}

\section{The $\lambda$-Calculus}

Despite the deep connection between $CCCs$ and the $\lambda$-calculus \todo{cite}
Lawvere's fixed point theorem has been relatively underexplored within the
field. In this section, a focus will be placed on the untyped
$\lambda$-calculus. A common theme in presentations of Lawvere's fixed point
theorem is the statement to the effect that the theorem allows for the
derivation of a fixed point combinator for the untyped $\lambda$-calculus.
Whilst being a claim repeated in several papers there does not appear to be a
proof associated with this. In contrast it is somewhat easier to find a proof
of the first fixed point theorem in the untyped $\lambda$-calculus. \todo{theorem}

In this thesis provide a novel proof is provided of the first fixed point
theorem using Lawvere's fixed point theorem. A simpler proof is also provided.
The proof in this thesis outlines an interesting phenomena and poses some
questions in the study of models of the $\lambda$-calculus. Both proofs rest on
a similar and simple observations of models of the $\lambda$-calculus and a
simple corollary of Lawvere's fixed point theorem. The observation in the
theory of the untyped $\lambda$-calculus, first made by Dana Scott in his
development of domain theory, is that models for the $\lambda$-calculus often
want to exploit the fact that $\lambda$-terms can be considered as objects of
the models but that $\lambda$-terms themselves are functions between
$\lambda$-terms. This naturally engenders a desire for some object $D$ that is
isomorphic to $D^D$, the function space on $D$. This is impossible for any set,
as shown by the previous section. Dana Scott solved this by constructing an
object $D_{\infty}$ as a complete partial order which will be outlined below.
This was later generalised by Koymans and Scott to be any Cartesian closed
category with an object $D$ which has a retraction to its own function space,
termed as a reflexive object.

The relationship between these constructions and Lawvere's theorem can be
understood by observing that in any $CCC$ with a reflexive object $D$ there is a
point surjective morphism from $D$ to $D^D$, precisely the retraction.
Formalising this in Agda first requires a formalisation of a reflexive object
and retractions. In an arbitrary category a retraction between two objects
\verb|A| and \verb|B| is

\ExecuteMetaData[../agda/latex/ThesisRetract.tex]{retract-def-retract}

i.e. A pair of arrows in both directions between \verb|A| and \verb|B| and a
proof that the composition of the two form the identity in a given direction.
A reflexive object is simply some object \verb|D| alongside a retraction,
\AgdaDatatype{Retract} \verb|D| $\verb|D|^{\verb|D|}$. Now the relevant
corollary to Lawvere's fixed point theorem can be stated precisely, working in a
CCC

\ExecuteMetaData[../agda/latex/ThesisY.tex]{Y-def-corollary}

The proof can be created by creating a point-surjective function from \verb|X|
to $\verb|X|^{\verb|X|}$ and applying the earlier proof of
\AgdaFunction{lawvere}. First, the retraction can be pattern matched on and
lawvere introduced with the arrow from \verb|X| to $\verb|X|^{\verb|X|}$ with
only a proof of point surjectivity required.

\ExecuteMetaData[../agda/latex/ThesisY.tex]{Y-def-corollary-body}

With \verb|b| being a general point to $\verb|X|^{\verb|X|}$, a point to
\verb|X| needs to be provided alongside a proof that \verb|b| is the solution to
the obvious equation \todo{fill in equation}. The point to \verb|X| is found by
using the retraction. The proof of equality is simply achieved by exploiting the
definition of a retraction to collapse the identity.

\ExecuteMetaData[../agda/latex/ThesisY.tex]{Y-point-surjective}


Understanding what this means requires looking at the specific of both models in
detail. First however what exactly it means to be a model of the
$\lambda$-calculus in general must be explored. \todo{cite $\lambda$-textbook}
$\bm{\lambda}$ refers to the equational theory of the same name outlined in
\todo{kerr's notes}. Models, in the model theoretic sense, are helpful for
exploring properties of the $\lambda$-calculus that are not immediate from the
equational theory and syntax itself, utilising discoveries from the field of
model theory. Providing a model for the $\lambda$-calculus was a difficult task,
primarily due to axioms of ordinary set theory (the axiom of regularity)
preventing a set from being an element of itself and thus a function from being
in its domain. With $\lambda$-terms being able to be considered as functions
between $\lambda$-terms this is an intimate problem with providing a set based
model. Several concrete models were provided since the first discovery of the
$\lambda$-calculus inclduing Scott's $D_{\infty}$, to be outlined later, Bohm's
tree model and Plotkin and Scott's $P\omega$ model. Despite these concrete
models of the $\lambda$-calculus, what exactly it meant to be a model of the
$\lambda$-calculus was less clear and only concretely defined later on by
\todo{who made $\lambda$-models}. For the equational theory $\bm{\lambda}$, the
class of structures which which constitute models are known as
$\lambda$-algebras. There are multiple formulations of $\lambda$-algebras, this
thesis will use several and point to proofs of equivalence within
\todo{barendregt}.

The definition of $\lambda$-algebras are predicated on the definition of an
applicative structure. An applicative structure is a tuple $M = (A \, , \,
\bullet)$ where $A$ is a set and $\bullet$ is a binary operation on $A$.

terms over a applicative structure

valuations in an applicative structure

The first set of models provided are the class known as environment or syntactic
models. A syntactic applicative structure adds a method of intepreting terms in
the $\lambda$-calculus, elements of the set $\Lambda$, into the applicative
struture. In other words a syntactic applicative structure is a triple $M = (A
\, , \, \bullet \, , \, \llbracket \, \rrbracket)$ of an underlying set $A$, a
binary operation $\bullet : A \rightarrow A$ and a syntactical intepretation
function $\llbracket \, \rrbracket$. Syntactical intepretations in an algebra,
$M$,  are functions $I : \Lambda(M) \times \textnormal{Val}(M) \rightarrow A$
where $\Lambda(M)$ is the set of all $\lambda$-terms, $\Lambda$, extended with
constants for each element in $M$ and Val$(M)$ is a function from strings to
elements of $M$, or a valuation.

definition of syntatic brackets.

satisfaction for syntactic structures

The constraint which turns a syntactic applicative structure, \textit{P}, into a
syntactic $\lambda$-algebra is
\begin{align*}
    \bm{\lambda} \vdash M = N \Rightarrow P \models \llbracket M \rrbracket = \llbracket N
    \rrbracket
\end{align*}

Or that every two $\lambda$-terms that are equal under $\bm{\lambda}$ are equal
under their intepretation within the $\lambda$-algebra. There is a close
relationship between $\lambda$-algebras and $CCCs$. Every $\lambda$-algebra can be
transformed into a $CCC$ with a reflexive object via the karoubi
envelope.\todo{karoubi} Furthermore, every $CCC$ with a reflexive object can be
turned into a $\lambda$-algebra such that taking a $\lambda$-algebra to a $CCC$
and back to $\lambda$-algebra again produces an isomorphic $\lambda$-algebra.
This indicates that every $\lambda$-algebra can be obtained by a $CCC$ with a
reflexive object. This relationship hints at an application of Lawvere's fixed
point theorem within the context of the $\lambda$-calculus. To examine this more
closely the implications of the corollary must be examined within the context of
both directions of the transformations.

A (locally small) $CCC$ with a reflexive object, $D$, with arrows $F : D
\rightarrow D^D$ and $G : D^D \rightarrow D$ can be turned into a
$\lambda$-algebra as follows. The underlying set of the $\lambda$-algebra are
the points to $D$, written $|D|$. The binary operation, $\star$, of the
generated $\lambda$-algebra that operates on points, $a$, $b$ to $D$ is as
follows:
\begin{align*}
    a \star b = eval \circ \langle \, F \times id \, \rangle \circ \langle a \,
    , \, b \,
    \rangle
\end{align*}

Barendregt defines a semantic intepretation function for $\lambda$-terms for
which the triple of $( \, |D| \, , \, \star \, , \, \llbracket \rrbracket \,)$
forms a $\lambda$-algebra.


Using the earlier corollary and the aformentioned transformation, lawvere's
fixed point theorem can be used to prove the first recursion theorem in every
$\lambda$-model. This can be shown in Agda as follows. In some Cartesian Closed
Category with a point surjective arrow, \AgdaFunction{PS.arr}, the operation
constituting $\star$ in the generated $\lambda$-algebra can be written as
follows

\ExecuteMetaData[../agda/latex/ThesisExtra.tex]{extra-applicative-op}

Proving the first fixed point theorem in every $\lambda$-algebra amounts to
showing that the following type is inhabited
\ExecuteMetaData[../agda/latex/ThesisExtra.tex]{extra-ffpt}

Or that every point to the reflexive object has a fixed point under $\star$. To
prove this, the fixed point must be provided and a proof that it is a fixed
point. The fixed point can be constructed as follows beginning by precomposing the
point-surjective arrow with the given point to \verb|f|

\begin{AgdaMultiCode}
\ExecuteMetaData[../agda/latex/ThesisExtra.tex]{extra-x-def}
\\
This gives a point to $\texttt{D}^\texttt{D}$. This can be turned into a
endomorphism on \verb|D| as follows by passing it through two familiar
isomorphisms
\\
\ExecuteMetaData[../agda/latex/ThesisExtra.tex]{extra-x-isos}
\\
Lawvere's fixed point theorem can now be used to find a fixed point for
\verb|y|
\\
\ExecuteMetaData[../agda/latex/ThesisExtra.tex]{extra-x-law}
\\
The fixed point and proof can be extracted as follows
\\
\ExecuteMetaData[../agda/latex/ThesisExtra.tex]{extra-x-fix}
\\
\verb|fixedPoint| is the fixed point for $\star$. Now, it needs to be shown that
\verb|fixedPoint| is in fact a fixed point for \verb|f| under $\star$ i.e.
\\
\ExecuteMetaData[../agda/latex/ThesisExtra.tex]{extra-fix-proof}
The definition of $\star$ can be expanded to
\\
\ExecuteMetaData[../agda/latex/ThesisExtra.tex]{extra-expand-pre}
\ExecuteMetaData[../agda/latex/ThesisExtra.tex]{extra-expand}
\\
From this point the proof proceeds in a similar fashion to the proof of
lawvere's fixed point theorem. The key observation here is that any point to
\verb|X| can composed with \AgdaFunction{Ps.arr} to give a point to
$\texttt{X}^{\texttt{X}}$ which can be pushed through familiar isomorphisms to
give a endomorphism on \verb|X|. The application of the generated applicative
structure amounts to converting the left hand point of the operation into an
endomorphism and then composing with the right hand point.
\\
\ExecuteMetaData[../agda/latex/ThesisExtra.tex]{extra-bulk-proof}
\ExecuteMetaData[../agda/latex/ThesisExtra.tex]{extra-bulk-proof1}
\\
The right hand side of the outermost composition now matches the constructed
\verb|y| from earlier \\
\ExecuteMetaData[../agda/latex/ThesisExtra.tex]{extra-bulk-proof1}
\ExecuteMetaData[../agda/latex/ThesisExtra.tex]{extra-almost}
\ExecuteMetaData[../agda/latex/ThesisExtra.tex]{extra-almost1} \\
\verb|fixedPointProof| can now be applied to make use of lawvere's fixed point
theorem. \\
\ExecuteMetaData[../agda/latex/ThesisExtra.tex]{extra-almost1}
\ExecuteMetaData[../agda/latex/ThesisExtra.tex]{extra-end}
\end{AgdaMultiCode}

Other insights can be gained from attempting to examine models of the Lambda
Calculus through the lens of lawvere's fixed point theorem. The applicative
structure generated by the above procedure can be considered for any CCC and any
arrow from an object to its function space. By adding more or less constraints
on the morphism, different types of models of the lambda calculus are gained.
Having enough points gives the so called $\lambda$-models, $\lambda$-algebras
that satisfy $\epsilon$
\todo{proofs}
\todo{having enough points}
\begin{align*}
    P \vDash \forall x (M = N) \rightarrow \lambda x . M = \lambda x
    . N
\end{align*}

If the reflexive object $D$ is strengthened to an isomorphism between $D \cong
D^D$ and has enough points then the applicative structure generated is not only
a $\lambda$-algebra but also satisfies the $\eta$ rule i.e.
\begin{align*}
    P \vDash \forall x (\lambda x . M x) = M
\end{align*}

A natural question that arises is the structure that gives rise to the
combinatory algebras. Just as $\lambda$-models are models of the
$\lambda$-calculus with $\beta$-equality, combinatory algebras are models of the
SK-calculus for the equational theory \textbf{CL} i.e. a 4-tuple $(A, \bullet,
k, s)$ with satisfies the following equations $\forall x y z \in A$

\begin{align*}
    &k x y = x \\
    &s x y z = x z (y z)
\end{align*}

Given that point surjectivity gives a fixed point theorem for any applicative
structure generated for it a natural question that arises is to what underlying
model of computation it might correspond. This thesis does not provide a
concrete answer to this question but provides some underlying combinators in
attempt to discover whether a complete set of combinators can be provided for
the applicative structure. An obviously complete set of combinators are the
classic S and K combinators. The combinators that are provided do not form a
complete basis but give the author some hope, alongside the fixed point theorem,
that point-surjectivity corresponds to a cohesive underlying structure.

The derivations of the combinators will be presented informally due to their
similarity to the above derivations with formal proofs being contained in the
appendix.

These combinators utilise the fact that $a \star b =
\overline{uncurry \, (\varphi \circ a)} \circ b$. If we are able to pick $a$
then we are able to recover any endomorphism on $D$. More precisely, for any $f:
D \rightarrow D$, this can be turned into a point to $D^D$ by pushing through
the other way in the $1 \times A \cong A$ isomorphism and exploiting the other
direction of the adjunction which we will call curry i.e. $f' = curry \, (
\,\underline{f} \,) : 1 \rightarrow D^D$. The point-surjectivity of $\varphi$
can now be used to find the equivalent $u$ such that $\varphi \circ u = f'$.
Considering $u \star b$ for any $b$ we get

\begin{align*}
    u \star b &= \overline{uncurry \, (\varphi \circ u \, )} \circ b \\
    &= \overline{uncurry \, ( \, f' \, ) } \circ b \\
    &= \overline{uncurry \, ( \, curry \, ( \, \underline{f} \, ) \, )} \circ b \\
    &= f \circ b
\end{align*}


A fairly easy combinator to construct is the identity combinator $\textbf{I} \, x =
x$ by taking $f$ in the above construction to be $id$ and calculating the
equivalent $u$.

Another useful combinator is the mockingbird or self-application operator,
$\textbf{M} x = x x$ by taking $f$ to be the following morphism of type $D
\rightarrow D$, $\textbf{M'} = eval \circ \langle \varphi \times id \rangle \circ
\delta$ and finding the equivalent $u$ and setting it to be \textbf{M}.

The final combinator we give a derivation for was found whilst attempting to
recover the \textbf{K} combinator and requires slightly more machinery.

Let $x = id : D \rightarrow D$, $y = curry \, ( \, \underline{x} \, ) : 1
\rightarrow D^D$ pick $z : 1 \rightarrow D$ s.t. $\varphi \circ z = y$ from the
point-surjectivity of $\varphi$ let $q = z \, \circ \, !_{D} : D \rightarrow D$
where $!_{D}$ is the terminal arrow from $D$. Taking $f$ as $q$ and deriving the
appropriate $u$ we get an interesting combinator. Calling the appropriate
$u$, \textbf{F}

\begin{align*}
    \textbf{F} \star a \star b &= (\textbf{F} \circ a) \star b \\
    &= eval \circ \langle \varphi  \times id \rangle \circ \langle q \circ a , b
    \rangle \\
    &= eval \circ \langle \varphi \times id \rangle \circ \langle z \, \circ \, !_{D}
    \, \circ \, a , \, b \rangle \\
    &= eval \circ \langle \varphi \circ z \times id \rangle \circ \langle !_{D} \,
    \circ \, a \, , \, b \rangle \\
    &= \overline{uncurry \, ( \varphi \circ z \, )} \circ b \\
    &= id \circ b \\
    &= b
\end{align*}
i.e. \textbf{F} selects the second of its two arguments. With some work perhaps
more combinators could be derived and, potentially, they will form a complete
basis for combinatory logic. Even if not , it is interesting to understand to
which computational world point-surjectivity corresponds.
