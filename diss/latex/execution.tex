% !TEX root = ./dissertation.tex
In this section the main contributions of this thesis will be presented. Working
towards a formalised version of Lawvere's fixed point theorem, definitions and
properties of points to objects will be explored. Following this, a detailed
proof of Lawvere's theorem will be presented in Agda. This will then be applied
to two separate domains: a category of types, and models of the untyped
$\lambda$-calculus. Within the category of types an analog of Cantor's theorem
will be derived after establishing its cartesian closedness. After The interplay
between cartesian closed categories and models of the untyped $\lambda$-calculus
will be examined and a novel result will be derived.
\section{Points}
Lawvere's fixed point theorem makes use of the notion of points and surrounding
definitions. The necessary definitions will be presented in Agda. Points are a
categorical abstraction that generalise the notion of elements of a set. A point
is an arrow from the terminal object to any other object

\ExecuteMetaData[../agda/latex/ThesisPoints.tex]{point-def-point}

Given the name of Lawvere's theorem it makes sense to formalise the notion of a
fixed point categorically

\ExecuteMetaData[../agda/latex/ThesisPoints.tex]{point-def-fixed-point}

A fixed point of a morphism is a point that is idempotent under composition to
the right with the morphism. As is common within the \verb|cats| library, this is
then wrapped up in a record as a sigma type to express that a given function has
a fixed point

\ExecuteMetaData[../agda/latex/ThesisPoints.tex]{point-def-has-fixed-point}

Now, the fixed point property, something which features in Lawvere's theorem, can be
formalised as a predicate on a object in a category expressing that all
endomorphisms on the object have a fixed point.

\ExecuteMetaData[../agda/latex/ThesisPoints.tex]{point-def-fixed-point-property}

Another concept that needs to be understood is the notion of point surjectivity
which itself requires some machinery. First the notion of a solved equation with
points

\ExecuteMetaData[../agda/latex/ThesisPoints.tex]{point-def-solution}

Point surjectivity expresses the notion that given a point to $B$, $(b : 1
\rightarrow B)$, and a morphism $f : A \rightarrow B$, we can produce a point to
$A$, $(a : 1 \rightarrow A)$, that satisfies the equation $f \circ a = b$.

Packaging this up into a sigma type which, given a morphism, \verb|f| from an object
\verb|A| to
an object \verb|B| and a point to \verb|B|, contains a point to \verb|A| and a proof that is
constitutes a solution to the triple.

\ExecuteMetaData[../agda/latex/ThesisPoints.tex]{point-def-has-solution}

A point surjective morphism is a function for which for every point to \verb|B| there
exists a solution

\ExecuteMetaData[../agda/latex/ThesisPoints.tex]{point-def-is-point-surjective}

The formulation of the point surjectivity used in the theorem is as a record
confirming the existence of a point surjective function between two objects

\ExecuteMetaData[../agda/latex/ThesisPoints.tex]{point-def-point-surjective}

\section{Lawvere's Fixed Point Theorem}

It is now possible to state Lawvere's theorem precisely, working within a
Cartesian Closed Category.

\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-type-diagonal}

Or mathematically that, in a cartesian closed category, if there exists a point-surjective
function from some object $A$ to the exponential object, $B^A$ then every endomorphism on $B$ has a fixed point.

The proof of the theorem will be developed line by line. The first step is to
pattern match on the arguments to the proof and bring in the constructors for
the output type.

\begin{AgdaMultiCode}
\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-pattern}
\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-pattern-end}
\end{AgdaMultiCode}

The first argument to the proof is the point-surjective morphism constituting
the underlying morphism and the proof of point-surjectivity, and the second
argument, \verb|f| is the
endomorphism on \verb|B|. The output requires a point to
\verb|B| alongside a proof that it is a fixed point of \verb|f|.

To produce a fixed-point, the goal is to create a morphism, \verb|g|, from \verb|A| to
\verb|B| and then exploit the point-surjective morphism to find a point to
\verb|A|. With the correctly chosen \verb|g| the composition of this point to A
with \verb|g| will be a fixed-point. \verb|g| will be constructed such that is
in some way "self-replicating".

\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-h-def}

where \AgdaFunction{$\delta$} is the unit of the diagonal-product adjunction and can
defined simply as
\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-delta}

Categorically, \verb|g| represents the following diagram

\[\begin{tikzcd}[sep=huge]
    B & B \arrow[l, "f"] & B^A \times A \arrow[l, "eval"] & A \times A \arrow[l,
    "{\langle \phi \, , id\rangle}"] & A \arrow[l, "\delta"]
\end{tikzcd}\]

In order to push \verb|g| morphism back through the point-surjective morphism
it needs to be turned into a point to the exponential object. This can be
achieved via two isomorphisms, $1 \times A \cong A$ and $\textnormal{hom}(A \times B \: , \, C)
\cong \textnormal{hom}(A \: , \, C^B)$. The directions of these isomorphisms
used in the proof are as follows
\begin{AgdaMultiCode}
\ExecuteMetaData[../agda/latex/ThesisExtension.tex]{extension-types-collapseToOne}
\ExecuteMetaData[../agda/latex/ThesisTypes.tex]{types-type-curry}
\end{AgdaMultiCode}

By applying the first isomorphism followed by the second, a point to $B^A$ can
be acquired
\begin{AgdaAlign}
\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-g'-def}

The point-surjectivity of $\phi$ can now be used to acquire the associated point
to \verb|A| with \verb|g'|

\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-ps-def}
\end{AgdaAlign}

The fixed point construction can now be achieved by composing $\phi$ with
\verb|u| twice to obtain a point to \verb|B|. After composing once with \verb|u|
a point to $B^A$ is obtained. This must be pushed through the aforementioned
isomorphisms to get a morphism, $A \rightarrow B$, to compose with \verb|u|
again.

\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-isos-proof}

Now it must be shown that \verb|f| $\circ$ \verb|fixedPoint| $\approx$
\verb|fixedPoint|. This proof will be developed using equational reasoning. The
proof starts with the word \AgdaFunction{begin} and the left-hand side of the
equality, with expressions separated by
equalities on morphisms, put inside
\AgdaOperator{\AgdaFunction{≈⟨}}\AgdaSpace{}\AgdaOperator{\AgdaFunction{⟩}}, and
ends with the right-hand side of the equality followed by
\AgdaOperator{\AgdaFunction{∎}}. In the case of the required proof

\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-fix-proof}

The first transformation in the proof is to use the point-surjectivity of
$\phi$ to expand the the $\phi$ $\circ$ \verb|u| within the definition of
\verb|fixedPoint| to \verb|g'|.

The proof of point-surjectivity is extracted as follows

\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-ps-proof}

This cannot be used directly due to the application of \AgdaFunction{curry} and
\AgdaFunction{extendToOne} to the expression. The usage of equivalence relations
means that congruence must be proved separately for every function on
morphisms. These two proofs have the following types but the proofs are elided
due to unnecessary complexity.

\begin{AgdaSuppressSpace}
\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-uncurry-resp-prf}
\ExecuteMetaData[../agda/latex/ThesisExtension.tex]{extension-coll21-r-type}
\end{AgdaSuppressSpace}

To make \verb|ps-proof| work within the nested function applications they are
wrapped in the two proofs of congruence necessary

\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-col-unc-ps}

This can then be used by targeting the lefthand morphism of the outermost
composition and change this to \verb|g'|. This is done using
\AgdaFunction{∘-resp-l} which allows a proof to be applied to chang the lefthand
side of a morphism composition.

\begin{AgdaMultiCode}
\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-col-unc-ps-trans}
\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-col-unc-ps-trans2}
\\
The next transformation is accomplished by utilising that \AgdaFunction{curry}
is an isomorphism with respect to \AgdaFunction{uncurry}, and that
\AgdaFunction{collapseToOne} is an isomorphism with respect to
\AgdaFunction{extendToOne}. With this \verb|g'| $\circ$ \verb|u| is obtained,
followed by expanding \verb|g'|, \\
\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-col-unc-ps-trans2}
\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-g'-reduc}
\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-g'-reduc1}
\\
Before begin able to manipulate this expression the expression must be
reassociated. This is particularly tedious.\\

\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-g'-reduc1}
\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-reassoc}
\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-reassoc1}
\\
Once this has been achieved, definitions can be expanded and applied.
Intuitively, it can be seen that the precomposition of a morphism by an arrow to
a product object can fused to push the precomposed morphism into each branch of
the product object.
\\
\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-reassoc1}
\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-in-u}
\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-in-u1} \\
To reproduce the original fixed point, $\phi$ should be composed with \verb|u|
followed by another composition with \verb|u|. To do this, a corollary of the
universal property for exponentials must be employed \\

\ExecuteMetaData[../agda/latex/ThesisExponential]{expon-eval-curry} \\

Actually applying this corollary requires more work as each transformation of product
objects must be made explicit \\
\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-in-u1}
\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-product-rearr}
\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-product-rearr1} \\
One \verb|u| must be brought into the left-hand product without the right-hand
one in order to match the universal property of exponentials. Another
requirement for \AgdaFunction{eval-curry} is that $\phi$ $\circ$ \verb|u| must
be wrapped inside \AgdaFunction{curry}. This can be done by applying the
\AgdaFunction{curry∘uncurry} isomorphism \\
\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-product-rearr1}
\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-curryuncurry}
\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-curryuncurry1} \\
Now, the universal property can be applied to extract \AgdaFunction{uncurry}
($\phi$ $\circ$ \verb|u|) from the product object \\
\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-curryuncurry1}
\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-eval-curry}
\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-eval-curry1} \\
The end is in sight and all that remains is to extract the second \verb|u|. This
is done by
collapsing $A \times 1$ to $A$, which can be achieved by inserting the identity
for $A \times 1$ and deconstructing this into the morphisms comprising the
isomorphism, \AgdaFunction{oneIso} and \AgdaFunction{otherIso}, and seeing what
happens \\
\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-eval-curry1}
\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-ax1-iso}
\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-ax1-iso1} \\
The isomorphisms happen to precisely be what is needed to recover the fixed
point \\
\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-ax1-iso1}
\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-iso-app}
\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-iso-app1} \\
Applying \AgdaFunction{projr} to the product object  extracts \verb|u| giving us
the fixed point \\
\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-proj-out}
\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-end} \\
The proof can be finished off by filling in the holes in the record \\
\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-record}
\end{AgdaMultiCode}

The contrapositive of the statement is worth defining as it is useful for some
of the applications.
\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-cantor}

\section{Applications}

Lawvere's fixed point theorem is an incredibly broad ranging theorem that
generalises many important theorems in mathematical logic and foundational
computer science. This thesis will formalise and axiomatize two
specific instances, Cantor's theorem the first fixed point theorem
in the untyped $\lambda$-calculus. An analog to Cantor's theorem will be introduced
alongside a category of small types in place of the category of sets.
After, categorical models of the $\lambda$-calculus will be explored and the
consequences of Lawvere's fixed point theorem in these models.
\subsection{Cantor's Theorem}
\label{section:cantor}
An analogue of Cantor's theorem can be constructed using a category of small
types (i.e. all types that belong to a given universe). A category can be
constructed from the elements of any Agda universe of a particular level by
setting the objects of the category to be the types of the universe and the
morphisms to be the functions between them.

\ExecuteMetaData[../agda/latex/ThesisSets.tex]{sets-instance}
Equality of morphisms is extensional propositional equality or functions.

\ExecuteMetaData[../agda/latex/ThesisSets.tex]{sets-equality}
Morphism composition is function composition, identity morphsism are identity
functions.

\ExecuteMetaData[../agda/latex/ThesisSets.tex]{sets-instance1}

The remaining axioms are trivially satisfied by the above definitions.Each
instance of \AgdaDatatype{Sets} forms a cartesian closed category. The remainder
of this section will be done with the lowest of these

\ExecuteMetaData[../agda/latex/ThesisCantor.tex]{cantor-univ}

The cartesian closedness of \AgdaDatatype{Sets1} will be established by
providing a terminal object, products and exponentials.  Proving that
\AgdaDatatype{Sets1} is cartesian requires showing that, for every pair of
types, a product object can be formed.

\ExecuteMetaData[../agda/latex/ThesisCantor.tex]{sets-product}

Product objects consist of an object, projections out of the object and a proof
that the objects and arrows satisfy the universal property of products. Products
correspond to the pair type

\ExecuteMetaData[../agda/latex/ThesisCantor.tex]{cantor-pair}


\ExecuteMetaData[../agda/latex/ThesisCantor.tex]{sets-proj}

All that remains is to prove that these constitute the product object i.e. that
for each pair of arrows from a type to each component of the pair there exists a
(extensionally propositionally) unique function from the type to the pair object
that satisfies the definition of the product.

\ExecuteMetaData[../agda/latex/ThesisCantor.tex]{cantor-unique-type}

Given the indexed-family \verb|p|, the unique arrow \verb|u| can be produced by extracting
the values from the indexed-family and creating a pair from them

\ExecuteMetaData[../agda/latex/ThesisCantor.tex]{cantor-unique-def}


Where \AgdaInductiveConstructor{Unique.Build.∃!{-}intro} is the constructor for
a universal mapping property.

The next field of the universal mapping type is the proof that the provided
arrow satisfies the definition required from the product i.e.

\ExecuteMetaData[../agda/latex/ThesisCantor.tex]{cantor-proj-sat}

Or in straightforward mathematical terms that the constructed arrow, \verb|u|,
satisfies with abuse of notation,
\begin{align*}
    \pi_{1} \circ \texttt{u} = f \land \pi_{2} \circ \texttt{u} = g
\end{align*}

Where $f$ and $g$ are the two morphisms underlying \verb|p|. This proves to be
trivially true given the definition of \AgdaFunction{proj-pair} and can be
directly placed as an argument to the universal mapping property.

\ExecuteMetaData[../agda/latex/ThesisCantor.tex]{cantor-unique-def1}

The final field of the universal mapping constructor is the proof that \verb|u|
is unique

\ExecuteMetaData[../agda/latex/ThesisCantor.tex]{cantor-unique}


For a category to have finite products it must also have a terminal object. The
terminal object in the category \AgdaDatatype{Sets1} is the unit type

\ExecuteMetaData[../agda/latex/ThesisUnit.tex]{unit-unit}

To prove that \AgdaDatatype{⊤} is in fact the terminal object the universal property
must be proven

\ExecuteMetaData[../agda/latex/ThesisCantor.tex]{cantor-terminal-prop1}

 The first argument to the constructor is
the unique arrow and the last the proof of uniqueness. The middle argument
ordinarily corresponds to the property the arrow must satisfy but the property
here is existence and so can be inferred automatically using an underscore as it
is trivially true that the type can be inhabited.

For a given type the function to the terminal object is the function that
constantly returns the single inhabitant of \AgdaDatatype{⊤}, \AgdaInductiveConstructor{tt}.

\ExecuteMetaData[../agda/latex/ThesisCantor.tex]{cantor-terminal-arrow}

The final component of the terminal object is the proof of uniqueness i.e. that
every function from a type to the terminal object is propositionally
(extensionally) equal. This
is trivially true as there is a single inhabitant of the unit type and therefore
only one place for to which all functions can map.

\ExecuteMetaData[../agda/latex/ThesisCantor.tex]{cantor-terminal-unique}

With this the universal mapping property can be completed

\ExecuteMetaData[../agda/latex/ThesisCantor.tex]{cantor-terminal-prop2}

And it can be established that \AgdaDatatype{Sets1} has a terminal object

\ExecuteMetaData[../agda/latex/ThesisCantor.tex]{cantor-tisterminal}


The last requirement for a cartesian closed category is exponentials. For every
pair of types an exponential object must be produced consisting of a type, an
evaluation map and transposition (currying). The exponential object for two
types \verb|A| and \verb|B| is the function type between the two

\ExecuteMetaData[../agda/latex/ThesisCantor.tex]{cantor-exponential}

The evaluation map takes a pair containing a function from a type \verb|A| to a
type \verb|B| and term of type \verb|A| and returns a \verb|B|. All that is
required here is to unpack the pair and apply the function to the value.

\ExecuteMetaData[../agda/latex/ThesisCantor.tex]{cantor-eval}

The last component that needs to be provided for exponentials is the curry
function which for the category of small types takes the form

\ExecuteMetaData[../agda/latex/ThesisCantor.tex]{cantor-curry'}

Which returns a universal mapping property. The first argument of the universal
mapping property, as is
usual, is the mapping itself which is the curry function.


\ExecuteMetaData[../agda/latex/ThesisCantor.tex]{cantor-curry}

The second argument is a proof that \AgdaFunction{sets-curry} satisfies the
universal property.

\ExecuteMetaData[../agda/latex/ThesisCantor.tex]{cantor-sets-curry'-sat}

By making use of the universal property for products

\ExecuteMetaData[../agda/latex/ThesisCantor.tex]{cantor-pair-prf}

The
proof can be completed trivially by reducing the left hand side of the propositional equality in the above type
\ExecuteMetaData[../agda/latex/ThesisCantor.tex]{cantor-sets-curry'-sat1}


The last component of the unique mapping property is the proof of uniqueness of
the map the type of which is

\ExecuteMetaData[../agda/latex/ThesisCantor.tex]{cantor-curry-uniq-type}

This proof proves to be difficult to complete.  This is an extensional proof equating the two desired structures
however, within MLTT, function extensionality is not derivable. Function extensionality
does not lead to inconsistencies within MLTT when postulated and therefore is
done here to allow the proof to proceed.

\ExecuteMetaData[../agda/latex/ThesisCantor.tex]{cantor-postulate}

Where extensionality equates functions that are pointwise equal

\ExecuteMetaData[../agda/latex/ThesisCantor.tex]{cantor-extensionality}

With extensionality the proof can be completed without significant difficulty


\ExecuteMetaData[../agda/latex/ThesisCantor.tex]{cantor-curry-uniq1}

The above defined function complete the definition of \AgdaFunction{set-curry'}

\ExecuteMetaData[../agda/latex/ThesisCantor.tex]{cantor-set-curry}

\AgdaDatatype{Sets1} can now be defined to be closed
\ExecuteMetaData[../agda/latex/ThesisCantor.tex]{cantor-hasexp}

With these definitions the CCCness of \AgdaDatatype{Sets1} can be trivially
established.

The category that has been is unfortunately not a valid model of set theory and
is only a toy language for reasons that can be found in Section
\ref{section:sets}.  A type theoretic analogue of Cantor's theorem can be
established showing there is no point-surjection from a type to the predicates
on the type. In set theory, for a given set, the predicates on the set can be
considered as subsets placing the elements of the powerset of a set in
correspondence with the predicates on the set. With no coherent notion of
membership relation or subset relation (by design) there is no way to faithfully
model the Cantor's theorem  within the category produced. Even so, the proof
shows, with enough similarity, how the argument would proceed in the category of
sets.

Within \AgdaDatatype{Sets1}, predicates are functions from a type \verb|A| to
\AgdaDatatype{Bool} type.

\ExecuteMetaData[../agda/latex/ThesisBool.tex]{bool-def}

With \AgdaDatatype{Bool}, Cantor's theorem can be reframed within
\AgdaDatatype{Sets1} as

\ExecuteMetaData[../agda/latex/ThesisCantor.tex]{cantor-cantor-type}

Or that, in English, for all types (in \AgdaDatatype{Set}) there does not exist
a point-surjection from the type to the predicates on the type. It is unclear
to the author as to whether point-surjectivity has a more coherent intepretation
within \AgdaDatatype{Sets1}.

To prove this  the contrapositive of
\AgdaFunction{lawvere}, \AgdaFunction{cantor} will be used. As a reminder

\ExecuteMetaData[../agda/latex/ThesisDiagonal.tex]{diagonal-cantor}

To make use of this it is necessary to show that \AgdaDatatype{Bool} does not
have the fixed point property.

\ExecuteMetaData[../agda/latex/ThesisCantor.tex]{cantor-nofixpt}

Recall that the definition of \AgdaFunction{¬} is

\ExecuteMetaData[../agda/latex/ThesisMisc.tex]{misc-negation}

Therefore, given a function which finds the fixed point of any function from
\AgdaDatatype{Bool} to \AgdaDatatype{Bool}, an inhabitant of void must be
provided. The observation that results in Cantor's theorem being an application
of Lawvere's theorem is that there is a function from \AgdaDatatype{Bool} to
\AgdaDatatype{Bool} that does not have a fixed point, the familiar function from
classical logic, negation or \AgdaFunction{not}.

\ExecuteMetaData[../agda/latex/ThesisCantor.tex]{cantor-not}

In fact, with respect to sets, every set with more than one element has at least
one function to itself without a fixed point leading to an extension of Cantor's
theorem i.e. that for all sets $A$ and $B$ with cardinality greater than one
there does not exist a surjective function from $A \rightarrow B^A$. Before
returning to \AgdaFunction{noFixPtBool}, a proof that \AgdaFunction{not} is
needed.

\ExecuteMetaData[../agda/latex/ThesisCantor.tex]{cantor-not-fx-type}

\AgdaFunction{not} \verb|x| reduces to a different normal form to \verb|x| for
both \AgdaInductiveConstructor{true} and \AgdaInductiveConstructor{false} and therefore the absurd pattern can
be introduced in both cases introduced using \verb|()| which indicate
that there is no constructor that is valid for the argument,

\ExecuteMetaData[../agda/latex/ThesisCantor.tex]{cantor-not-fx}

Here the absurd patterns are used,  given that the
\AgdaFunction{not-fx-pt} is now used to derive \AgdaFunction{noFixPtBool}
through a contradiction. \AgdaFunction{¬}\AgdaFunction{noFixPtBool} is a function
which, given a proof that \AgdaDatatype{Bool} has a fixed property, can derive
false. The proof that \AgdaDatatype{Bool} has the fixed point property can be
used to derive a fixed point for \AgdaFunction{not} which we have already proven
does not have a fixed point. This is done through the \AgdaKeyword{with}
construct within Agda. \AgdaKeyword{with} allows an intermediate computation to
be pattern matched on. In the case of \AgdaFunction{noFixPtBool} it is the
result of applying the proof of the fixed proof property \verb|Y|, a fixed point
combinator, to the \AgdaFunction{not} function.

\ExecuteMetaData[../agda/latex/ThesisCantor.tex]{cantor-nofixpt1}

Through this, a fixed-point, \verb|X| of \AgdaFunction{not} can be extracted alongside a
proof of \verb|X| fixed pointedness.

\ExecuteMetaData[../agda/latex/ThesisCantor.tex]{cantor-nof-def}

Now, within the scope of the \AgdaFunction{noFixPtBool}, there exist proofs that
\AgdaFunction{not} both does and doesn't have a fixed point.
\AgdaFunction{not-fx-pt} has takes an equality of \AgdaFunction{not} \verb|x|
and \verb|x| and returns an element of \. It is clear that by
the proof of the existence of a fixed point to this will derive \AgdaDatatype{⊥} as
needed.

\ExecuteMetaData[../agda/latex/ThesisCantor.tex]{cantor-nof-final}

\AgdaFunction{cantorsDiagonalTheorem} can now be derived as a direct application
of \AgdaFunction{cantor}

\begin{AgdaMultiCode}
    \ExecuteMetaData[../agda/latex/ThesisCantor.tex]{cantor-cantor-type}
    \ExecuteMetaData[../agda/latex/ThesisCantor.tex]{cantor-cantor}
\end{AgdaMultiCode}
\subsection{The $\lambda$-Calculus}
\label{quote:lambda}
There is much to suggest that a coherent interpretation of Lawvere's theorem
exists in the $\lambda$-calculus. The untyped $\lambda$-calculus is famous for
Curry's fixed point combinator of which a consequence is that
every $\lambda$-term has a fixed point under application (known as the first
fixed point theorem) indicating that perhaps a direct
application in an appropriate category could yield this result. In addition to
this, significant results in different models of computation are given as an
application of the theorem as outlined in Section \ref{section:yanofsky}. This observation has not
gone unnoticed by others. \verb|nLab| \cite{nlab:homepage}, an online encyclopedia
for category theory,  hosts a webpage for Lawvere's fixed point
theorem \cite{nlab:lawvere's_fixed_point_theorem} which states in \textbf{Remark 2.6}.

\begin{displayquote}
\textit{Many applications of Lawvere’s fixed point theorem are in the form of negated
propositions, e.g., there is no surjection from a set to its power set, or
Peano arithmetic cannot prove its own consistency. However, there are positive
applications as well, e.g., it implies the existence of fixed-point combinators
in untyped lambda calculus.}
\end{displayquote}

This claim affirms the notion that Curry's fixed combinator could be derived as
an instance of Lawvere's theorem. Despite this remark, the realities of the
situation are not so simple. The \verb|nLab| page does not provide a source for
their remark and, within the literature, there are only informal proofs of this
claim. Upon further examination the informal proofs do not truly reflect Lawvere's theorem in the
context of the untyped $\lambda$-calculus. These
previously presented proofs will be examined more closely in Section
\ref{quote:prior}. In this
thesis a precise account of the relationship indicated within
the remark on \verb|nLab| will be presented, which does not quite extend to establishing the
existence of fixed point combinators within the $\lambda$-calculus but a
straightforward corollary - the first fixed point theorem. The first fixed point
theorem states that all $\lambda$-terms have a fixed point under application.

The proof that Lawvere's theorem implies the existence of fixed points for all
$\lambda$-terms rests on the observation first made by Dana Scott in his
development of domain theory, that $\lambda$-terms can also be considered as functions between $\lambda$-terms. This naturally
engenders a desire for some object $D$ that is isomorphic to $D^D$, the function
space on $D$. This is impossible for any set within a set theory that rejects
unrestricted comprehension. Various specific models were constructed through the
latter half the of 20$^{\textrm{th}}$ century. These
ideas were later generalised by identifying that all models of the
$\lambda$-calculus arise from cartesian closed category with an object $D$ that
has a retraction to its own function space, known as a reflexive object.

The relationship between these constructions and Lawvere's theorem can be
understood by observing that in any $CCC$ with a reflexive object $D$ there is a
point surjective morphism from $D$ to $D^D$, precisely the retraction.
Formalising this in Agda first requires a formalisation of a reflexive object
and retractions. In an arbitrary category a retraction between two objects
\verb|A| and \verb|B| is

\ExecuteMetaData[../agda/latex/ThesisRetract.tex]{retract-def-retract}

i.e. A pair of arrows in both directions between \verb|A| and \verb|B| and a
proof that the composition of the two form the identity in a given direction.
A reflexive object is simply some object \verb|D| alongside a retraction,
\AgdaDatatype{Retract} \verb|D| $\verb|D|^{\verb|D|}$. Now the relevant
corollary to Lawvere's fixed point theorem can be stated precisely, working in a
CCC

\ExecuteMetaData[../agda/latex/ThesisY.tex]{Y-def-corollary}

The proof can be created by creating a point-surjective function from \verb|X|
to $\verb|X|^{\verb|X|}$ and applying the earlier proof of
\AgdaFunction{lawvere}. First, the retraction can be pattern matched on and
Lawvere introduced with the arrow from \verb|X| to $\verb|X|^{\verb|X|}$ with
only a proof of point surjectivity required.

\ExecuteMetaData[../agda/latex/ThesisY.tex]{Y-def-corollary-body}

With \verb|b| being a general point to $\verb|X|^{\verb|X|}$, a point to
\verb|X| needs to be provided alongside a proof that \verb|b| is the solution to
the point-surjective equation. The point to \verb|X| is found by
using the retraction. The proof of equality is simply achieved by exploiting the
definition of a retraction to collapse the identity.

\ExecuteMetaData[../agda/latex/ThesisY.tex]{Y-point-surjective}


The implications of this corollary can be understood from this excerpt from section
5 of Barendregt's \textit{The Lambda Calculus: Its Syntax and Semantics}
\cite{barendregt1992lambda} on
models.

\begin{displayquote}
\textit{"\ldots for the construction of a $\lambda$-calculus model it
is sufficient to have an object $D$ in a CCC such that $D^D$ is a retract of
$D$."}
\end{displayquote}

From the above quote and the earlier corollary to Lawvere's theorem it can be
concluded that the categorical interpretation of every model of the
$\lambda$-calculus has an object with the fixed point property.

In the section that follows, several are results are stated without proof for
brevity. The relevant theorems and definitions from \textit{The Lambda Calculus:
Its Syntax and Semantics} will be pointed to for reference. Models, in the
model-theoretic sense, are helpful for exploring properties of the
$\lambda$-calculus that are not immediate from the equational theory and syntax
itself. The general class of structures that are models of the
$\lambda$-calculus are known as $\lambda$-algebras. The definition of
$\lambda$-algebras are predicated on the that of an applicative structure. An
applicative structure is a tuple $M = (A \, , \, \bullet)$ where $A$ is a set
and $\bullet$ is a binary operation on $A$.

A useful type of models to be considered are the class of syntactic models. A
syntactic applicative structure adds a method of intepreting terms in the
$\lambda$-calculus, elements of the set $\Lambda$, into the applicative
struture. In other words a syntactic applicative structure is a triple $M = (A
\, , \, \bullet \, , \, \llbracket \, \rrbracket)$ of an underlying set $A$, a
binary operation $\bullet : A \rightarrow A$ and a syntactical intepretation
function $\llbracket \, \rrbracket$. See \textbf{Definitions 5.3.1} and
\textbf{5.3.2} in \cite{barendregt1992lambda} for a precise definition of
$\llbracket \, \, \rrbracket$ and an appropriate definition of satisfaction,
$\vDash$.

The constraint which turns a syntactic applicative structure, \textit{P}, into a
syntactic $\lambda$-algebra is
\begin{align*}
    \bm{\lambda} \vdash M = N \Rightarrow P \models \llbracket M \rrbracket = \llbracket N
    \rrbracket
\end{align*}

Or that every two $\lambda$-terms that are equal under $\bm{\lambda}$ are equal
under their intepretation within the $\lambda$-algebra. There is a close
relationship between $\lambda$-algebras and CCCs. Every $\lambda$-algebra can
be transformed into a CCC with a reflexive object via a process known as the
\textit{Karoubi Envelope}. Furthermore, every CCC with a
reflexive object can be turned into a $\lambda$-algebra such that taking a
$\lambda$-algebra to a CCC and back to $\lambda$-algebra again produces an
isomorphic $\lambda$-algebra, established in \textbf{Theorem 5.5.13.}. This indicates that every $\lambda$-algebra can be
obtained by a CCC with a reflexive object. The results of applying
\AgdaFunction{corollary} can be interpreted in both directions of this transformation.
Intepreting within the context of the transformation from \textit{Karoubi
envelope} to CCC yields no sensical results. The construction of the
\textit{Karoubi envelope} and the investigation of its relationship with
Lawvere's theorem are detailed in Appendix \ref{appx:karoubi}. Interpreting in
the other direction, however, is more useful.

A locally-small CCC with a reflexive object, $D$, with arrows $F : D
\rightarrow D^D$ and $G : D^D \rightarrow D$ can be turned into a
$\lambda$-algebra as follows. The underlying set of the $\lambda$-algebra are
the points to $D$, written $|D|$. The binary operation, $\star$, of the
generated $\lambda$-algebra that operates on points, $a$, $b$ to $D$ is as
follows:
\begin{align*}
    a \star b = eval \circ \langle \, F \times id \, \rangle \circ \langle a \,
    , \, b \,
    \rangle
\end{align*}

\textbf{Definition 5.5.3.} defines a semantic intepretation function for
$\lambda$-terms for which the triple of $( \, |D| \, , \, \star \, , \,
\llbracket \rrbracket \,)$ is shown to be  a $\lambda$-algebra in
\textbf{Theorem 5.5.6.}.


With \AgdaFunction{corollary} and the fact that the above transformation yields
all $\lambda$-models, Lawvere's fixed point theorem can be used to prove the
first fixed point theorem in all $\lambda$-models. The proof proceeds as
follows. In some cartesian closed category with a point surjective arrow,
\AgdaFunction{PS.arr}, the operation constituting $\star$ in the generated
$\lambda$-algebra can be written as follows

\ExecuteMetaData[../agda/latex/ThesisExtra.tex]{extra-applicative-op}

Proving the first fixed point theorem in every $\lambda$-algebra amounts to
showing that the following type is inhabited
\ExecuteMetaData[../agda/latex/ThesisExtra.tex]{extra-ffpt}

Or that every point to the reflexive object has a fixed point under $\star$. To
prove this, the fixed point must be provided and a proof that it is a fixed
point. The fixed point can be constructed as follows beginning by precomposing the
point-surjective arrow with the given point to \verb|f|

\begin{AgdaMultiCode}
\ExecuteMetaData[../agda/latex/ThesisExtra.tex]{extra-x-def}
\\
This gives a point to $\texttt{D}^\texttt{D}$. This can be turned into a
endomorphism on \verb|D| as follows by passing it through two familiar
isomorphisms
\\
\ExecuteMetaData[../agda/latex/ThesisExtra.tex]{extra-x-isos}
\\
Lawvere's fixed point theorem can now be used to find a fixed point for
\verb|y|
\\
\ExecuteMetaData[../agda/latex/ThesisExtra.tex]{extra-x-law}
\\
The fixed point and proof can be extracted as follows
\\
\ExecuteMetaData[../agda/latex/ThesisExtra.tex]{extra-x-fix}
\\
\verb|fixedPoint| is the fixed point for $\star$. Now, it needs to be shown that
\verb|fixedPoint| is in fact a fixed point for \verb|f| under $\star$ i.e.
\\
\ExecuteMetaData[../agda/latex/ThesisExtra.tex]{extra-fix-proof}
The definition of $\star$ can be expanded to
\\
\ExecuteMetaData[../agda/latex/ThesisExtra.tex]{extra-expand-pre}
\ExecuteMetaData[../agda/latex/ThesisExtra.tex]{extra-expand}
\\
From this point the proof proceeds in a similar fashion to the proof of
lawvere's fixed point theorem. The key observation here is that any point to
\verb|X| can composed with \AgdaFunction{Ps.arr} to give a point to
$\texttt{X}^{\texttt{X}}$ which can be pushed through familiar isomorphisms to
give a endomorphism on \verb|X|. The application of the generated applicative
structure amounts to converting the left hand point of the operation into an
endomorphism and then composing with the right hand point.
\\
\ExecuteMetaData[../agda/latex/ThesisExtra.tex]{extra-bulk-proof}
\ExecuteMetaData[../agda/latex/ThesisExtra.tex]{extra-bulk-proof1}
\\
The right hand side of the outermost composition now matches the constructed
\verb|y| from earlier \\
\ExecuteMetaData[../agda/latex/ThesisExtra.tex]{extra-bulk-proof1}
\ExecuteMetaData[../agda/latex/ThesisExtra.tex]{extra-almost}
\ExecuteMetaData[../agda/latex/ThesisExtra.tex]{extra-almost1} \\
\verb|fixedPointProof| can now be applied to make use of lawvere's fixed point
theorem. \\
\ExecuteMetaData[../agda/latex/ThesisExtra.tex]{extra-almost1}
\ExecuteMetaData[../agda/latex/ThesisExtra.tex]{extra-end}
\end{AgdaMultiCode}

The above theorem shows that the syntactic applicative structure generated from
any CCC with a point surjective morphism has a fixed point theorem. To connect
this result back the terms of the $\lambda$-calculus and the equational theory
$\lambda\beta$,  \textbf{Theorem 5.2.18 (i)} from \cite{barendregt1992lambda} must
be considered which states

\begin{theorem*}
    For all $M, N \in \Lambda \; \; \; \lambda\beta \vdash  M = N \Leftrightarrow M =
    N$ is true in all $\lambda$-models
\end{theorem*}

Given the earlier established fact that all $\lambda$-models can be obtained
from CCCs with a reflexive object and that all CCCs with a reflexive object
induce a syntactic applicative structure with a fixed point theorem it is
possible to conclude, therefore, that the $\lambda$-calculus has a fixed point
theorem under application. Whilst not the briefest or most insightful proof, it 
 raises further questions concerning categorical intepretations
of the untyped $\lambda$-calculus. $\lambda$-algebras are all the models that,
for their interpretation of $\lambda$-terms, satisfy the equations of
$\lambda\beta$. Other structures exist that aim to characterise all models for
which other equational theories hold of their intepretation of $\lambda$-terms.
For instance, $\lambda$-models are an extension of $\lambda$-algebras which also
satisfy the Meyer-Scott axiom of weak-extensionality. 


The class of CCCs that give rise to the $\lambda$-models are those with a
reflexive object that \textit{has enough points}. An object, $A$, has enough
points if for all $f$, $g : A \rightarrow A$

\begin{align*}
    f \neq  g \implies \exists \: x : 1 \rightarrow X \; \; \; f \circ x \neq g \circ x
\end{align*}


Furthermore there are the extensional $\lambda$-algebras that correspond the
equational theory which satisfies the $\eta$ rule i.e.

\begin{align*}
    P \vDash \forall x (\lambda x . M
    x) = M
\end{align*}

The class of CCCs that give rise to these structures are those with an object
$D$ that \textit{has
enough points} but, instead of $D$ being reflexive is instead
isomorphic to its exponential object i.e. $D \equiv D^{D}$.

Given that point surjectivity gives a fixed point theorem for any applicative
structure generated for it a natural question that arises is to what underlying
structure it might correspond. The notion is certainly weaker than that of
certainly weaker than that of a $\lambda$-algebra as the arrow from $D^{D}
\rightarrow D$ for a reflexive object is made use of when defining the semantic
intepretation function giving rise to $\lambda$-algebras. This thesis does not
provide a concrete answer to this question, see Section \ref{section:combin},
but provides some combinators that are derivable in any applicative structure
derived from a CCC with a point surjective object. The derivations of the
combinators will be presented informally due to their similarity to the above
derivations with formal proofs being contained in the appendix.

These combinators utilise the fact that $a \star b =
\overline{uncurry \, (\varphi \circ a)} \circ b$. If  $a$ can be picked
then, any endomorphism on $D$ can be recovered. More precisely, for any $f:
D \rightarrow D$, this can be turned into a point to $D^D$ by pushing through
the other way in the $1 \times A \cong A$ isomorphism and exploiting the other
direction of the adjunction, here given the name curry i.e. $f' = curry \, (
\,\underline{f} \,) : 1 \rightarrow D^D$. The point-surjectivity of $\varphi$
can now be used to find the equivalent $u$ such that $\varphi \circ u = f'$.
Considering $u \star b$ for any $b$

\begin{align*}
    u \star b &= \overline{uncurry \, (\varphi \circ u \, )} \circ b \\
    &= \overline{uncurry \, ( \, f' \, ) } \circ b \\
    &= \overline{uncurry \, ( \, curry \, ( \, \underline{f} \, ) \, )} \circ b \\
    &= f \circ b
\end{align*}


A fairly easy combinator to construct is the identity combinator $\textbf{I} \, x =
x$ by taking $f$ in the above construction to be $id$ and calculating the
equivalent $u$.

Another useful combinator is the mockingbird or self-application operator,
$\textbf{M} x = x x$ by taking $f$ to be the following morphism of type $D
\rightarrow D$, $\textbf{M'} = eval \circ \langle \varphi \times id \rangle \circ
\delta$ and finding the equivalent $u$ and setting it to be \textbf{M}.

The final combinator a derivation is given for was found whilst attempting to
recover the \textbf{K} combinator and requires slightly more machinery.

Let $x = id : D \rightarrow D$, $y = curry \, ( \, \underline{x} \, ) : 1
\rightarrow D^D$ pick $z : 1 \rightarrow D$ s.t. $\varphi \circ z = y$ from the
point-surjectivity of $\varphi$ let $q = z \, \circ \, !_{D} : D \rightarrow D$
where $!_{D}$ is the terminal arrow from $D$. Taking $f$ as $q$ and deriving the
appropriate $u$ an interesting combinator is derived. Calling the appropriate
$u$, \textbf{F}

\begin{align*}
    \textbf{F} \star a \star b &= (\textbf{F} \circ a) \star b \\
    &= eval \circ \langle \varphi  \times id \rangle \circ \langle q \circ a , b
    \rangle \\
    &= eval \circ \langle \varphi \times id \rangle \circ \langle z \, \circ \, !_{D}
    \, \circ \, a , \, b \rangle \\
    &= eval \circ \langle \varphi \circ z \times id \rangle \circ \langle !_{D} \,
    \circ \, a \, , \, b \rangle \\
    &= \overline{uncurry \, ( \varphi \circ z \, )} \circ b \\
    &= id \circ b \\
    &= b
\end{align*}
i.e. \textbf{F} selects the second of its two arguments.
