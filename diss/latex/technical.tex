% !TEX root = ./dissertation.tex
This section will outline the essential technical details to understand the
primary contributions of this thesis. This section will aim to to provide a
working knowledge of the theory behind and the usage of the Agda theorem prover.
Through Agda, the underlying theory of categories will be explained to
sufficiently understand Lawvere's fixed point theorem. As explained prior,
theorem provers often work by utilising the Curry-howard isomorphism to embed a
logical framework within the type system of a programming language. This is the
approach taken by the Agda theorem prover which makes use of a type system
similar to that of Martin Lof Type theory, a type theory which provides a
logical framework for intutionistic higher-order logic.

\section{\mlt{} Type Theory}
The approach to theorem proving taken in this thesis is a type theoretic
approach exploiting the \cuho{} correspondence. This will be done in the
dependent type theory designed by \mlt{}. Martin Lof's type theory (MLTT) was intended to be an
entirely constructive foundation in which mathematics could be done. Just as,
inline with the \cuho{} correspondence, the intutionistic fragment of
natural deduction has an interpretation within the simply-typed
$\lambda$-calculus, MLTT has a logical interpretation as first-order
intuitionistic predicate logic by including dependent types in the theory. The
theory is outlined below, a more detailed examination can be found notes derived
from \mlt's lectures \cite{martin1984intuitionistic} or Chapter One of the
\textit{Homotopy Type Theory} book \cite{hottbook}. \mlt's lecture notes
discuss the philosophical ramifications of his theory and advocate for its use
as a foundation for all of mathematics.

Within MLTT, typing takes the form of a judgement. Judgements are statements in
the metatheory of the type theory that can either be derived from the deductive
rules of the type theory or introduced independently. The judgement that a term
$a$ has type $A$ is written
\begin{align*}
    a: \, A
\end{align*}

The other primary judgement of MLTT is equality. Equality equates
two terms in the sense that one can be replaced with the other freely within the
theory. This allows new constructions to be introduced within the theory through
naming and functions. The judgement that
two terms, $a$ and $b$ are equal (at type $A$) is written

\begin{align*}
    a \equiv b \, : \, A
\end{align*}

Types are introduced by introducing equalities that define how to form and use
the types within the context of the theory. In the section that follows, only a
limited number of types will be introduced so as to understand how the type
theory can be used in theorem proving. Before defining types, however, what it
means to be a type must be introduced. A universe is a type whose elements are
themselves types. The version of MLTT presented here postulates an infinite
hierarchy of universes, $U_{n}$ which is an element of the universe at a higher
level $U_{n+1}$ i.e.

\begin{align*}
    U_{0} : U_{1} : U_{2} \cdots
\end{align*}

A type is then an inhabitant of some universe. One might desire some finite
number of universes in which to work and this was something \mlt{} desired.
Martin-Log's first presentation of his type theory featured only one universe,
$U$, which was an element of itself.

\begin{align*}
    U : U
\end{align*}

Thierry Coquand in 1992 showed that a Russell style paradox could be embedded
within a type theory with a single impredicative universe. This mirrors the
inconsistencies that develop when trying to postulate a set of all sets in naive
set theory. A type is then defined to bean element of one of the postulated
universes and new types can be defined within a given universe.



Introducing new types into the type theory involves explaining how to create
objects of that type and how to compute with objects of the type, done by adding
more definitional equalities to the system.  The most basic components of MLTT
is the dependent function or Pi-type, $\Pi$. $\Pi$-types represent functions
where the output type of a function can depend on the argument to the function.
If $A$ is a type (i.e. $A : U$ for some universe $U$) and $B : U$  the
$\Pi$-type,

\begin{align*}
    \prod_{(x : A)}B
\end{align*}
which binds the variable $x$ in B, represents the dependent function which takes
an argument $x : A$ and returns an element of type $B$ with the free variable
$x$ replaced with the argument to the function. A dependent function, $f :
\prod_{(x : A)}B$, can be introduced via a set of defining equations or via a
$\lambda$-abstraction. Given an expression $M : B$ where $B$ may contain the
variable $x : A$ $f$ can be defined as
\begin{align*}
    f (x) :\equiv M \textrm{ for } x : A
\end{align*}
Another way to introduce a dependent function is to introduce a $\lambda$ which
takes an identifier and an expression and produces a dependent function i.e.
\begin{align*}
    \lambda \, x . M : \prod_{(x : A)}B(x)
\end{align*}
Computing with $\prod$-types occurs through application and substitution. Given
a dependent function, $f(x) \equiv M : \prod_{(x : A)}B(x)$, and a value $a : A$, $a$ can be
applied to $f$ to obtain a value of type $B(a)$ written
\begin{align*}
    f(a) : B(a)
\end{align*}
\todo{uniqueness principle for pi types}

The expression that the the application yields is the result of replacing all
instances of $x$ in $M$ with $a$. With depenent functions it is possible to
capture the notion of a \textit{type-family}. A type-family is a $\Pi$-type that
returns an element of some universe written. The other types to be introduced in
this section can be written as inductive types. Inductive types can be
introduced by supplying constructors with build elements of the type from other
types.  Inductive types can be computed with using induction principles which
describe how to compute with abitrary structures of the type based on the
constituent parts. Induction principles can be seen as an alternative to pattern
matching, a more common feature of functional programming languages. A simple
type to illustrate this is the product type which is the type theory analogue of
the cartesian product. Given two types $A : U_{n}$ and $B : U_{n}$ the product
type, $A \times B : U$ can be formed. Given $a : A$ and $b : B$ an element of
the pair type $A \times B$ can be constructed as
\begin{align*}
    (a \, , \, \, b) \, : \, A \times B
\end{align*}
Before introducing the induction principle for product types it is worth
dwelling on some subtleties of induction principles. Induction principles are
judgemental equalities that are describe how to compute with newly introduced
data types. Induction principles often provide a separate defining function for
each constructor for a type however this is \textit{not} pattern matching. A
separate defining equation for each constructor often makes logical sense for
the type to have good computational properties but there is an element of choice
to designing induction principles as shall be seen in the discussion of the
identity type. The induction principle for products is a function with the type

\begin{align*}
    \textsf{ind}_{A \times B} : \prod_{C : A \times B\rightarrow
    U}(\prod_{(x : A)}\prod_{(y : B)}C((x , y))) \rightarrow \prod_{x : A\times
    B}C(x)
\end{align*}

Intuitively, this type can be read as, given a type family $C : A \times B
\rightarrow U$ for some universe, $U$, and given a dependent function which
takes two arguments returns the type family applied to the pair of the two
functions, a dependent function for pairs can be produced. More concisely, a
function for pairs can be produced from a function that takes two arguments.
Intuitively this can be done by taking the function with two arguments,
deconstructing the pair and applying each component of the pair in turn. As a
defining equation this is:
\begin{align*}
    \textsf{ind}_{A \times B}\, (C, g, (a , b)) :\equiv g(a)(b)
\end{align*}
Other types that are integral to the theorem-proving effort are $\Sigma$-types.
$\Sigma$-types or dependent pairs. Dependent pairs are product types where the
type of the second argument can depend on the first. Given a type $A : U$ and a
type-family $B : A \rightarrow U$ the dependent product type $\Sigma_{(x :
A)}B(x)$ can be formed. Given an element $a : A$ and an element $b : B(a)$ the
dependent pair $(a,b) : \Sigma_{(x : A)}B(x)$. The induction principle for
$\Sigma$-types is similar to the induction principle for products.

\begin{align*}
    \textsf{ind}_{\Sigma_{x :A}B(x)} : \prod_{C : \Sigma_{x : A }B(x)\rightarrow
    U}\bigg(\prod_{(x : A)}\prod_{(y : B)}C((x , y))\bigg) \rightarrow \prod_{p :
    \Sigma_{x : A}B(x)}C(x)
\end{align*}
with the same defining equation
\begin{align*}
    \textsf{ind}_{\Sigma_{x :A}B(x)}\, (C, g, (a , b)) :\equiv g(a)(b)
\end{align*}


The coproduct type is the typed variant of the disjoint union from set theory.
For two types $A : U$ and $B : U$ coproduct of $A$ and $B$ is $A + B : U$.
induction principle

unit
induction principle

void

A final and key component of MLTT is the identity type, a type used to prove
that two terms are equal. This is known as propositional equality and is
internal to the theory. For a given type, $A : U$, the identity type is a family
$\textsf{Id}_{A} : A \rightarrow A \rightarrow U$ for a given $a : A$, $b : A$
written $a =_{A} b$. Within MLTT there is a single inhabitant of the identity
type for a given  $a : A$  which can only be introduced if the second elements
of $A$ are definitionally equal known as $\textsf{refl}_{a}$. $\textsf{refl}$ is
a constructor of type
\begin{align*}
    \textsf{refl} : \prod_{a : A}(a =_{A} a)
\end{align*}

There are different choices for induction principle for the identity type.
Choosing whether to use both or only one is major decision in modern type
theories. One of the induction principles for the identity type is known as
\textsf{Axiom J}. \textsf{Axiom J} is a function of type

\begin{align*}
    \textsf{ind}_{=_{A}} : \prod_{(C : \Pi_{(x,y : A)}(x=_{A}y)\rightarrow
    U)}\bigg(\prod_{(x : A)}C(x,x,\textsf{refl}_{x})\bigg) \rightarrow
    \prod_{(x,y:A)}\prod_{p:x=_{A}y}C(x,y,p)
\end{align*}

\textsf{Axiom J} is defined as
\begin{align*}
    \textsf{ind}_{=_{A}} (C,c,x,x,\textsf{refl}_{x}) :\equiv c(x)
\end{align*}


The basis upon which MLTT can be used as a foundation for mathematics is via the
\cuho{} correspondence in a particular fashion known as
propositions-as-types.

\subsection{Propositions-as-types}
Propositions-as-types hinges on intepreting a proof of a proposition as an
inhabitant of a correponding type. The types presented in the previous section
are the types with which higher order intutionistic logic can be intepreted.
With types instead of sets, universal quantification over a type can be
simulated using $\Pi$-types where the output type of the dependent function is
the proposition being quantified over. Existential quantification can be
intepreted as $\Sigma$ types where the second argument is the proposition being
quantified over and the first argument is the object that satisfies said
proposition. Implication is a non-dependent function type, logical conjuction
corresponds to product types, coproduct types to logical disjunction. Truth is
inhabitation of the unit type and falsity as an inhabitant of the void type. The
void type has no inhabitants and so any such inhabitant would constitute a proof
of the inconsistency of the logic the type system represents. With this
definition of falsity, negation is a function that takes a type (proposition)
and produces and inhabitant of the void type, something that should not be
possible. The intutionistic, constructive component of this logic comes from the
fact that to prove a position an element of a type \textit{must} be constructed.
A proof of $A \land B$ consists of providing a proof of $A$ \textit{and}
providing a proof of $B$. This constructive approach to logic weakens the
deductive framework.

\todo{double negation/excluded middle}
The propositions-as-types intepretation of logic is
proof-relevant, proving, within the type theory, that two things are equal uses
the identity type. An inhabitant of the identity type is an object within the
type-theory presenting a equality between two things.


\section{Agda}

Agda is a dependently typed functional language in which theorem can be done.
Agda can be used as a proof assistant through the lens of the \cuho{}
correspondance given it's type system. Agda uses Haskell like syntax and its
underlying type theory is based of that of Per \mlt. The following
describes features of Agda available in version 2.52, the version employed in
this thesis. Agda uses a predicative hierarchy of universes,
\AgdaPrimitive{Set}, indexed by a natural-number like type
\AgdaPrimitive{level}. \AgdaPrimitive{Set} can be viewed as a type-family
returning a universe.

A term \verb|t| of a given type, \AgdaDatatype{A} can be introduced and named
in Agda as follows

\ExecuteMetaData[../agda/latex/ThesisMisc.tex]{misc-name}


where \AgdaDatatype{name} : \AgdaDatatype{A} indicates that the identifier
\AgdaDatatype{name} has type \AgdaDatatype{A} and the second line assigns to
\AgdaDatatype{name} the value to the right hand sign of the equals sign,
\AgdaDatatype{t}. Unlike other typed programming languages, the types of
identifiers cannot be elided and inferred by the compiler. In the presence of
dependent types, the problem of type inference becomes undecidable and therefore
it is preferable to explicitly annotate them for all identifiers. Agda provides
a limited number of the constructions provided in Martin Lof type theory and
instead provides a method for defining inductive datatypes allowing inductive
types such as dependent pairs, product and coproduct types to be defined. One of
the constructions provided by are Pi types. A Pi type can be introduced with an
identifier, \AgdaFunction{foo}, as follows

\ExecuteMetaData[../agda/latex/ThesisMisc.tex]{misc-pi}

where, in the type signature, \verb|x| is an identifier of type \AgdaDatatype{A}
which may appear in the output type \AgdaDatatype{B}. The \verb|x| to the
lefthand side of the equals sign in the function definition binds the identifier
\verb|x| as an argument to the function of type \AgdaDatatype{A} which may be
used in the term \AgdaDatatype{M} of type \AgdaDatatype{B}. Arguments to a
function need not have the same names in the type and definition of the function
e.g.
\ExecuteMetaData[../agda/latex/ThesisMisc.tex]{misc-pi'}

is a valid definition.

As in MLTT, functions can also be introduced using a $\lambda$-abstraction. A
downside of this is that the arguments of a $\lambda$-abstraction can not be
pattern matched on in the body of a function.


Inductive data types can be introduced as follows.

\ExecuteMetaData[../agda/latex/ThesisMisc.tex]{misc-inductive1}

The \AgdaKeyword{data} keyword is followed by the name of the inductive data
type. Before the colon in the first line are the parameters to the type.
Parameters to a type appear as is in constructors to the type. They indicate
that the type behaves parametrically with respect to them. This is why in the
constructors \verb|Parameter| appears as is. Indices, on the other hand, appear
after the colon. Indices can change the shape of the type depending on the
constructor. In the example given the index is an inhabitant of the natural
number type and the first constructor dictates the inhabitant of the natural
number type is \AgdaInductiveConstructor{0} and in the second constructor that
the inhabitant is \AgdaInductiveConstructor{1}. The final term before the
\AgdaKeyword{where} statement is the output univerese of the type i.e. to which
\AgdaDatatype{Set} the type belongs. The constructors of the Inductive data type
are the possible inhabitants of the type. When pattern matching onto an
inductive data type, information is gained about the type based on the index
corresponding to the constructors produced by the pattern match.

Many constructions within Agda are common enough that they are desirable at all
levels of universe. Agda does not have cumulativity so, to assist universe
generic programming, universe polymorphism can be used.

\todo{unit and void}

A more useful example to consider is the sized list type, or vector

\ExecuteMetaData[../agda/latex/ThesisMisc.tex]{misc-inductive}

The curly braces in the type definition indicate implicit arguments, arguments
Agda will try and infer from other arguments. \AgdaDatatype{Vec} features set
polymorphism, parameters and indices. The two constructors for
\AgdaDatatype{Vec}, are indexed by their size. The empty list has size
\AgdaInductiveConstructor{zero} to indicate its emptiness.
\AgdaOperator{\AgdaInductiveConstructor{\AgdaUnderscore{}∷\AgdaUnderscore{}}}
takes an element of type \verb|a| and a Vector of size \verb|n| and appends the
singleton to the beginning creating a vector of size
\AgdaInductiveConstructor{suc} \verb|n|. When pattern matching onto a
\AgdaDatatype{Vec}, information is gained about the inductive argument to the
type i.e for the empty list has size \AgdaInductiveConstructor{zero} and in the
inductive case that the list has size \AgdaInductiveConstructor{suc} \verb|n|
for some \verb|n|. The remaining important types of \mlt type theory can
now be introduced as inductive types beginning with Sigma types.
\todo{mixfix syntax}

\ExecuteMetaData[../agda/latex/ThesisMisc.tex]{misc-sigma}

The output universe for sigma must be the maximum of the levels of the first and
second components of the sigma type which can be done using \todo{lub}. The
product type is defined similarly.

\ExecuteMetaData[../agda/latex/ThesisMisc.tex]{misc-product}

and coproducts

\ExecuteMetaData[../agda/latex/ThesisMisc.tex]{misc-coproduct}

Instead of introducing induction and recursion principles for inductive data
types, Agda instead opts for deep pattern matching whereby an inductive datatype
can be expanded into its constitutent components. This is justified by the fact
that all inductive data types possible of being defined within (normal) Agda
correspond to W types i.e. types that admit a well-founded induction principle.
An example of pattern matching can be used to define a projection out of product
types.

\ExecuteMetaData[../agda/latex/ThesisMisc.tex]{misc-projl}

\todo{pattern match that introduces information}

The final type needed before propositions-as-types can be employed is the
equality type which is defined as follows

\ExecuteMetaData[../agda/latex/ThesisMisc.tex]{misc-equality}

For each inhabitant of \verb|A|, \verb|x|, there is unique inhabitant of the
equality type parameterised by \verb|x| which is when the second indexed
argument to the equality type normalises to the first parameter. This
restriction can only be made if the second argument is an index so we are able
to restrict its shape.

Proving theorems with no additional features in the language would prove
difficult. Mathematical structures would be a pain to define in the standard
inductive style as often they will often consist of a single constructor with
arguments that depend on each other. To assist with these types of structure
record types exist. Records are extensions of $\Sigma$-types which have named
fields to assist with referring to the individual components, an illustrative
example is the definition of a monoid, $(S \, , \, \bullet , \, e)$, within Agda

\ExecuteMetaData[../agda/latex/ThesisMisc.tex]{misc-monoid}

where \AgdaDatatype{lsuc} is the equivalent of \AgdaDatatype{suc} but for
levels. \todo{underscore}This is required due to \AgdaField{$\bullet$} which
forces the implicit constructor for the type to be of a higher sort than
\AgdaField{S} itself, due to the predicativity of the underlying type theory.
The identifiers to the left hand side of the colon under the \AgdaKeyword{field}
keyword in the above definitions define projections out of a
\AgdaDatatype{Monoid} object. The first three fields correspond to the elements
of a tuple representing a monoid, the underlying set, binary operation and
identity element.

Another limitation within the currently outlined framework with respect to
proving theorem is the definition of the equality type. In a world where where
Agda used induction principles instead of pattern matching, \textsf{Axiom J},
would, in some sense, not be strong enough to be useful when proving a
significant number of theorems. The problem, being addressed can be introduced
by considering a homomorphism type for the above definition of monoid

\begin{AgdaMultiCode}
\ExecuteMetaData[../agda/latex/ThesisMisc.tex]{misc-monhom}
\ExecuteMetaData[../agda/latex/ThesisMisc.tex]{misc-monhom1}
\end{AgdaMultiCode}

where the fields of the second monoid are postfixed with an apostrophe. Consider
showing two monoids are propositionally equal. For records, this amounts to
showing that its fields are equal i.e that the underlying functions are the
same but \textit{also} the proofs of preservation of identity and and operation
are the same. The proof-relevant nature of the underlying type theory enables
two different proofs to be distinguished by their normal form. It would be
unreasonable and beside-the-point to demand this when equating two monoids but
it is \textit{required} when equating using propositional equality. This is a
well understood problem with various solutions \todo{find solutions}. The
approach taken in standard Agda is to employ an additional axiom on the identity
type known as Streicher's \textsf{Axiom K} \cite{streicher1993investigations}.
\textsf{Axiom K} is an axiom that enables it to be proven that all inhabitants
of the identity type are \textsf{refl}. Introducing \textsf{Axiom K} into MLTT
turns the theory into a proof-irrelevant one. The proofs for both structures
can be reduced to refl and then equated propositionally and all that remains is
showing equality of functions. Introducing \textsf{Axiom K} is not without its
downsides however. Recent advancements in type theory \cite{hottbook}
show that there are signifcant advantages to working within a proof-relevant
setting which are inconsistent with \textsf{Axiom K}. These are discussed in
Section \ref{section:limitations}.

The last limitation that must be addressed is pertinent to the goal of
formalising category theory within type theory. Returning again to considering
equality of monoid homomorphisms, by employing \textsf{Axiom K}, showing
equality of monoid homomorphisms amounts solely to showing equality of
functions. Within set theory, it is common to equate functions that are
pointwise equal

\begin{align*}
    (\forall x \; f(x) = g(x)) \implies f=g
\end{align*}

This notion of equality ignores, for better or worse, the computational content
of the individual functions. It does not matter if functions are operationally
different but only that they are functionally different. This principle is not
derivable within standard MLTT and therefore, if it is going to be used, it must
be postulated as an axiom. For many, a distinct advantage of computer-aided
theorem proving using types is its intrinsically constructive interpretation and
therefore it is common to avoid axioms such as function extensionality within
the type theory.


A common solution within the type theory of unmodified Agda is the setoid
approach. A setoid is a set or type alongside an equivalence relation \todo{add
setoid def}. Setoids can be used to work with and prove properties of
extensional equalities without introducing a new axiom. This is pertinent to
category theory as, often, structures like monoids and monoid homorphisms are
the subject of examination and a useful notion of equality is essential for
making progress. Proofs with respect to the equivalence relation can be done in
a largely similar way to using propositional equality using the properties of
reflexivity, transitivity and symmetry of the equivalence relation \todo{monoid
example}.  Other situations in which it is preferable to use setoids is when
working with algebraic structures where the underlying equality is not truly
propositional equality for example the monoid consisting of the rational numbers
under addition. Commonly the rational numbers are defined as a pair of integers
however equality on fractions usually consists of equality of their reduced
forms, generating an equivalence class of fractions. In general quotiented
structures are not readily available within standard MLTT.

The primary limitation when opting for setoid equality over propositionally
equality is the inability to employ indecernability of identicals or congruence
a natural consequence of \textsf{Axiom J}. This is an advantage of
propositionally equality since this property must be proven for each equivalence
relation separately, in some circumstances adding on a significant amount of
work. Recent advancements in type theory have produced a type theory in which
function extensionality can be derived and has computational content, discussed
in \todo{hott section}.

\section{Category Theory}

\subsection{Basic Definitions}
Category theory is a unifying field of mathematics that examines abstract
structure. A category, \textbf{C}, is a mathematical structure containing a
class objects and a class of morphisms or directed relations between said
objects. Many expositions of category theory are somewhat vague surrounding
exactly mathematical structures that objects and arrows are. If objects and
arrows are \textit{sets} of things, swathes of mathematical objects are
inaccessible to category theory because they are too large due to Russell's
paradox style problems such as a category of all sets or a category of all
categories. This was a main motivation behind \mlt's theory of types by
defining categories and the objects and arrows of categories as types. By paying
closer attention to what is in the metatheory versus internal to theory i.e. set
membership versus a typing judgement and by paying closer attention to the
predicativity of the system in question, \textit{larger} objects can safely be
embedded in the system\todo{explain more}. In the informal presentation of
category theory, as is prevelant in the literature, no firm foundations will be
provided so as to aid in understanding. This will be followed by a formal
presentation of the constructions within Agda. To repeat, a category is a
collection of objects and a collection of arrows between objects.
\begin{align*}
    &\textrm{Obj} : A \\
    &\textrm{Arr} : A \rightarrow B
\end{align*}

In Agda, categories can be constructed in with relative simplicity. The initial
concepts introduced here are taken from \verb|cats|, a Category Theory library
in Agda by Jannis Limpberg. \AgdaBound{lo}, \AgdaBound{la} and \AgdaBound{l≈}
are used in the following section as variables of type \AgdaDatatype{Level}.

Categories can be introduced as a record parameterised by the level of their
objects, arrows and type of morphism equality respectively

\ExecuteMetaData[../agda/latex/ThesisCategory.tex]{cat-def}

Categories are typed at a level above the largest of objects, arrows and
equalities in order to present equality on morphisms as relations on types as
per the Agda standard library. In addition to objects and arrows, there exists a
binary operation on morphisms known as composition which takes two morphisms,
$f : A \rightarrow B$ and $g : B \rightarrow C$ and produces a third morphism
$g \circ f : A \rightarrow C$. Furthemore, for each object, $A$, in the
category, there exists an identity arrow $id_{A} : A \rightarrow A$.
\begin{align*}
    &\textrm{Identity} : \forall A \in \textrm{Obj}(\textbf{C}) \, \, \exists \, \, id : A \rightarrow A \\
    &\textrm{Composition} : \textrm{Given } f : A \rightarrow B
    \textrm{ and } g : B \rightarrow C \, \exists \, \, g \circ f : A \rightarrow C
\end{align*}

In Agda, identity arrows and composition take their obvious definitions. The identity
arrow provides a distinguished morphism for each object implicitly and
composition is a function that takes two morphisms of the correct shape and
returns the appropriate morphism
\ExecuteMetaData[../agda/latex/ThesisCategory.tex]{cat-field-comp-id}

The current operations defined for a category must adhere to a few more axioms,
namely
\begin{align*}
    &\textrm{Neutrality of identity} : \forall \, g : A \rightarrow B \, \, \, \,
    g \circ id_{A} = g \textrm{  and    } \forall f : C \rightarrow D \, \,  \, \,
    id_{D} \circ f = f \\
    &\textrm{Associativity of Composition} : \forall \, f \, , g \, \, , \,  h \, \, \,
    \, \, ((h \circ g) \circ f) = (h \circ (g \circ f))
\end{align*}

As mentioned in the previous section, when codifying equalities on morphisms,
such as associativity of composition and the neutrality of identity within
Agda, it is often not practical to use propositional equality. It is common to
work with categories with which the morphisms are functions between types
equipped with additional structure. To work with these in standard Agda, either
extensionality must be postulated or setoids must be used. There are other
factors involved with the decision between equality on morphsims being
propositional or setoid such as performance and ease-of-use, some of which is
discussed in.

\ExecuteMetaData[../agda/latex/ThesisCategory.tex]{cat-field-rel}

The \AgdaFunction{IsEquivalence} function establishes the appropriate proofs of
reflexivity, transitivity and symmetry.

With the notion of equality of morphisms in place it is possible to state the
properties of composition and identity

\ExecuteMetaData[../agda/latex/ThesisCategory.tex]{cat-field-comp}

The field \AgdaField{∘{-}resp} is the result of the aformentioned lack of
fongruence for equivalence relations. Preserves2 indicates that composition is
congruent in both of its arguments. This allows us to target individual
compositions in a large categorical term to apply an equality. This is given for
free when using propositional equality as functions are unable to distinguish
terms with the same normal form. This can be seen as one of the downsides to
using equivalence relations as congruence must be proven for every each
individual equivalence relation.\todo{congruence}

There are many examples of categories throughout mathematics and computing. The
category of groups, \textbf{Group}, has as its objects groups and its morphisms
group homomorphisms. The category of sets, \textbf{Set}, has as its objects sets
and its morphsisms total functions. A category of types will be introduced in
\ldots which will be used to explore an application of lawvere's theorem
\subsection{Universal Constructions}

A key idea of category theory are universal constructions. Universal
constructions are common patterns that occur throughout mathematics
that aim to capture the essence of these patterns at the categorical level. The
universal constructions presented here are those that will be of use within the
thesis.

\subsubsection{Terminal Objects}
Terminal objects are constructions that capture the minimal structure required
to be an object within a category. They often correspond to the trivial examples
of objects within the category.  A terminal object of a category \textbf{C} is
an object, $T$, such that, for all other objects, $A$ in the category, there
exists a unique arrow $!_{A}: A \rightarrow T$. This can be shown as a diagram
where the dashed line indicates uniqueness.

\[\begin{tikzcd}[sep=huge]
A \arrow[d, "!_A", dashed] \\
T
\end{tikzcd}\]

As is common with universal constructions, terminal objects in categories are
unique up to unique isomorphism. Examples of terminal objects in common
categories include any singleton in \textbf{Set} and the one element group in
\textbf{Group} Formalising universal constructions within Agda requires the
notion of unique arrow

\ExecuteMetaData[../agda/latex/ThesisUnique.tex]{unique-def-unique}

Uniqueness is often given with respect to a property (hence universal
properties). In Agda this amounts to formulating the property as type
parameterised by the property and an arrow satisfying the property. The type
encodes a function which, given any other arrow satisfying the property
expresses equality to the parameterised arrow. Using this a general unique arrow
can be encoded using a trivial function that always returns the unit. Universal
properties can now be given as an object, a proposition and a proof of
uniqueness

\ExecuteMetaData[../agda/latex/ThesisUnique.tex]{unique-def-exun}

Agda has support for custom syntax directives which can be used to create a
universal mapping type postulating the existence of a unique arrow. Below is an
example of defining products using this where \todo{grab exists}, desugars to
the universal property type above.

\ExecuteMetaData[../agda/latex/ThesisUnique.tex]{unique-def-terminal}

A category having a terminal object can now be encoded as a proposition which
takes a category and provides an object alongside a proof that it is terminal

\ExecuteMetaData[../agda/latex/ThesisTerminal.tex]{terminal-def-has}

Lawvere's fixed point theorem is a theorem about cartesian closed categories.
Cartesian closed categories are categories with three specific universal
properties, a terminal object, binary products and exponentials. Having a terminal
object and binary products is also called having finite products. Therefore the
definition of a CCC in Agda is appropriately.

\ExecuteMetaData[../agda/latex/ThesisCCC.tex]{ccc-def-is-ccc}

\subsubsection{Products}
Products exemplify a common construction in categories of combining the
structure of two objects (in some canonical way) within the category to produce
an object of the same category. In more concrete terms the product of two
objects $A$ and $B$ in the category $\textbf{C}$ is an triple $(A \times B,
\pi_{1}, \pi_{2})$ where for all other objects $C$ in $\textbf{C}$ with
projections $f: C \rightarrow A$ and $g: C \rightarrow B$ the unique arrow
$\langle f, g\rangle : C \rightarrow A \times B$ can be formed such that the
following diagram commutes:

\[\begin{tikzcd}[sep=huge]
 & C \arrow[ld, "f"'] \arrow[rd, "g"] \arrow[d, "{\langle f, g\rangle}" description, dashed] &  \\
A & A \times B \arrow[l, "\pi_2"] \arrow[r, "\pi_1"'] & B
\end{tikzcd}\]

where the dashed arrow indicates uniqueness. This can be extended to
\textit{n}-ary products in the obvious way.

As with terminal objects, products are unique up to unique isomorphism. Examples
of products within familiar categories include the cartesian product $\times$ in
\textbf{Set}, defined as the set of all tuples of elements from two separate
sets. If products can be formed for every finite set of objects in a category it
is said to be cartesian.

Products have a slightly more involved definition than terminal objects. Beginning
with the uniqueness principle for products

\ExecuteMetaData[../agda/latex/ThesisProduct.tex]{product-def-product}

\AgdaFunction{IsProduct} takes an indexing function, a product object, and some
projections out of the product into the components of the indexing category.
\AgdaFunction{IsProduct} returns a function type which, upon being supplied a
set of projections from an object to the indexing set, returns a unique arrow
from the the object to the previously supplied product object satisfying the
commuting diagrams for the product. A product object for a given indexed family
of objects \verb|O| can be defined as the product object itself,
\AgdaField{prod}, the projections out of the product object, \AgdaField{proj},
and the proof of uniqueness, \AgdaField{isProduct}.

\ExecuteMetaData[../agda/latex/ThesisProduct.tex]{product-def-prod}

A binary product is a product where the function that indexes the family of
objects is the a boolean elimination function

\ExecuteMetaData[../agda/latex/ThesisProduct.tex]{product-def-bool}
\ExecuteMetaData[../agda/latex/ThesisProduct.tex]{product-def-binprod}

A category containing binary products can be encoded as a category equipped with
a operation that, for every pair of objects, \verb|A| and \verb|B|, produces the
product object for the pair.

\begin{AgdaMultiCode}
\ExecuteMetaData[../agda/latex/ThesisBinProd.tex]{binprod-has-binary-products}
\ExecuteMetaData[../agda/latex/ThesisBinProd.tex]{binprod-times}
\\
For notational convenience a function that returns the object within the
category from a particular product object is useful.\\
\ExecuteMetaData[../agda/latex/ThesisBinProd.tex]{binprod-obj}
\\
Also useful are the projections out of the product \\
\ExecuteMetaData[../agda/latex/ThesisBinProd.tex]{binprod-projr}
\ExecuteMetaData[../agda/latex/ThesisBinProd.tex]{binprod-projl} \\
and the methods of forming the unique arrows \\
\ExecuteMetaData[../agda/latex/ThesisBinProd.tex]{binprod-unique-arr}
\ExecuteMetaData[../agda/latex/ThesisBinProd.tex]{binprod-unique-pair}
\end{AgdaMultiCode}

Examples of products include the direct-product of groups in \textbf{Group} and
the cartesian product of sets in \textbf{Set}. A category with a terminal object
and products is said to have finite products and is a cartesian category.

\subsubsection{Exponentials}

Exponential objects are universal constructions that capture the notion of
function spaces or higher order objects. The exponential, $B^{A}$, indicates the
mappings from the object $A$ to $B$. This is paired with the morphism $eval:
B^{A} \times A \rightarrow B$ such that for any object $Z$ and morphism $f :
Z\times A \rightarrow B$ there exists a unique morphism $\tilde{f}: Z
\rightarrow B^{A}$ such that the following diagram commutes:

\[\begin{tikzcd}[sep=huge]
    B^{A} \times A \arrow[r, "eval"]
    & C \\
    A \times B \arrow[ru, "f"'] \arrow[u, "\langle \: \hat{f} \: \times \: id
    \rangle"] &
\end{tikzcd}\]

$\tilde{f}$, or transposition, can be thought of as currying in the functional
programming sense, taking a function in multiple arguments to a sequence of
functions in one argument.

In Agda, an exponential object for objects \verb|B| and \verb|C| consist of an
object

\begin{AgdaMultiCode}
\ExecuteMetaData[../agda/latex/ThesisExponential.tex]{expon-exp}
\\
the evaluation map
\\
\ExecuteMetaData[../agda/latex/ThesisExponential.tex]{expon-eval}
\\
and the uniquness principle for products
\\
\ExecuteMetaData[../agda/latex/ThesisExponential.tex]{expon-unique}\\
For ease of use the function producing the unique arrow can be extracted.\\
\ExecuteMetaData[../agda/latex/ThesisExponential.tex]{expon-curry}
\end{AgdaMultiCode}

A category that has exponentials is one that  where the exponetial object can be
formed for every pair of objects

\begin{AgdaMultiCode}
\ExecuteMetaData[../agda/latex/ThesisHasExp.tex]{hasexp-def}
\ExecuteMetaData[../agda/latex/ThesisHasExp.tex]{hasexp-exp}
\\
A convenient exponential operation can be defined that extracts the object
\\
\ExecuteMetaData[../agda/latex/ThesisHasExp.tex]{hasexp-expo}
\\
With a generic evaluation map
\\
\ExecuteMetaData[../agda/latex/ThesisHasExp.tex]{hasexp-eval}
\\
and \AgdaFunction{curry} and \AgdaFunction{uncurry} as isomorphisms
\\
\ExecuteMetaData[../agda/latex/ThesisHasExp.tex]{hasexp-curry}
\ExecuteMetaData[../agda/latex/ThesisHasExp.tex]{hasexp-uncurry}
\\
\end{AgdaMultiCode}

In \textbf{Set}, the exponential object for two sets is the set of all functions
between them.

\todo{add ending}
