% !TEX root = ./dissertation.tex
This section will outline the essential technical details to understand the
primary contributions of this thesis. This section will aim to to provide a
working knowledge of the theory behind and the usage of the Agda theorem prover.
Through Agda, the underlying theory of categories will be explained to
sufficiently understand Lawvere's fixed point theorem. As explained prior,
theorem provers often work by utilising the Curry-howard isomorphism to embed a
logical framework within the type system of a programming language. This is the
approach taken by the Agda theorem prover which makes use of a type system
similar to that of Martin Lof Type theory, a type theory which provides a
logical framework for intutionistic higher-order logic.

\section{Martin Lof Type Theory}
The approach to theorem proving taken in this thesis is a type theoretic
approach exploiting the curry-howard correspondence. This will be done in a
dependent type theory designed by Per Martin Lof, a logician working in
intutionistic logic. Martin Lof's type theory (MLTT) was
intended to be an entirely constructive foundation in which mathematics could be
done. Just as, inline with the curry-howard correspondence, the intutionistic
fragment of natural deduction has an interpretation within the simply-typed
$\lambda$-calculus, MLTT has a logical interpretation as first-order
intuitionistic predicate logic by including dependent types in the theory.

MLTT adopts the Church-style view of typing in which terms cannot be brought in
without a unique type. This is done by introducing typing as a judgement of the
type theory. The judgements of a theory are the conclusions that can be made
given the deductive rules of said theory. The judgement that a term $a$ has type
$A$ is written

\begin{align*}
    a: \, A
\end{align*}

The other primary judgement of MLTT is that of judgemental equality. Judgemental
equality is used to introduce new constructions into the theory as definitional
equalities to allow us to introduce and name new constructions and to establish
when two terms normalise to the same term. The judgement that two terms,
$a$ and $b$ are equal (at type $A$) is written

\begin{align*}
    a \equiv b \, : \, A
\end{align*}

Inductions and recursion principles


Types are introduced by introducing definitional equalities that define how to
form and use the types within the context of the theory. In the section that
follows, only a limited number of types will be introduced so as to understand
how the type theory can be used in theorem proving. Among the most basic
components of MLTT is the function type $\rightarrow$.

(dependent) Function types: intro, formation, computation, elimintation, propeq
sigma: intro, formation, computation, elimintation, propeq
product: intro, formation, computation, elimintation, propeq

Universes/ predicativity

\section{Agda}

Agda is a dependently typed functional language in which theorem can be done.
Agda can be used as a proof assistant through the lens of the curry-howard
correspondance given it's type system. Agda uses Haskell like syntax and its
underlying type theory is based of that of Per Martin-Lof. The following
describes features of Agda available in version 2.52, the version employed in
this thesis. Agda uses a predicative hierarchy of universes,
\AgdaPrimitive{Set}, indexed by a natural-number like type
\AgdaPrimitive{level}. \AgdaPrimitive{Set} can be viewed as a type-family
returning a universe.

A term \verb|t| of a given type, \AgdaDatatype{A} can be introduced and named
in Agda as follows


where \verb|term| : \AgdaDatatype{A} indicates that the identifier \verb|term| has
type \AgdaDatatype{A} and the second line assigns to \verb|term| the value to
the right hand sign of the equals sign. Unlike other typed programming
languages, the types of identifiers cannot be elided and inferred by the
compiler. In the presence of dependent types, the problem of type inference
becomes undecidable and therefore it is preferable to explicitly annotate them
for all identifiers. Agda provides a limited number of the constructions
provided in Martin Lof type theory and instead provides a method for defining
inductive datatypes allowing inductive types such as dependent pairs, product
and coproduct types to be defined. One of the constructions provided by
are Pi types. A Pi type can be introduced with an identifier, \verb|foo|, as follows

\todo{pi type intro}

Computation and elimination rules work adequately similar to MLTT. Inductive
data types can be introduced as follows.
\todo{inductive datatypes}
definition

Instead of introducing induction and recursion principles for inductive data
types, agda insetad opts for deep pattern matching whereby an inductive datatype
can be expanded into its constitutent components.

proof that pattern matching for inductive data types is sound.
constructors

pattern matching vs induction/recursion principles.
records

categories
monoids
setoids
